<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Map functions · Healpix.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Healpix.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../resolutions/">Working with resolutions</a></li><li><a class="tocitem" href="../pixelfunc/">Pixel functions</a></li><li class="is-active"><a class="tocitem" href>Map functions</a><ul class="internal"><li><a class="tocitem" href="#Unseen-pixels-and-nothingness"><span>Unseen pixels and nothingness</span></a></li><li><a class="tocitem" href="#Encoding-the-order"><span>Encoding the order</span></a></li><li><a class="tocitem" href="#Pixel-functions"><span>Pixel functions</span></a></li><li><a class="tocitem" href="#Loading-and-saving-maps"><span>Loading and saving maps</span></a></li><li><a class="tocitem" href="#Testing-for-conformability"><span>Testing for conformability</span></a></li><li><a class="tocitem" href="#Interpolation"><span>Interpolation</span></a></li><li><a class="tocitem" href="#Upgrading-and-Downgrading"><span>Upgrading and Downgrading</span></a></li><li><a class="tocitem" href="#Map-making"><span>Map-making</span></a></li></ul></li><li><a class="tocitem" href="../alm/">Spherical harmonics</a></li><li><a class="tocitem" href="../visualization/">Visualization</a></li><li><a class="tocitem" href="../misc/">Miscellanea</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Map functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Map functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ziotom78/Healpix.jl/blob/master/docs/src/mapfunc.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Map-functions"><a class="docs-heading-anchor" href="#Map-functions">Map functions</a><a id="Map-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Map-functions" title="Permalink"></a></h1><p>Functions like <a href="../pixelfunc/#Healpix.pix2angNest-Tuple{Resolution, Any}"><code>pix2angNest</code></a> and <a href="../pixelfunc/#Healpix.ang2pixNest-Tuple{Resolution, Any, Any}"><code>ang2pixNest</code></a> fully define the Healpix tessellation scheme. They are however extremely impractical in a number of situations. It happens often that a large fraction of pixels in a map need to be processed together. Healpix.jl introduces the <a href="#Healpix.HealpixMap"><code>HealpixMap{T, O &lt;: Order}</code></a> type, which acts as a collection of all the pixels on the sphere. A <code>HealpixMap</code> type holds the value of all the pixels in its <code>pixels</code> field, and it keeps track of the ordering (either <code>RING</code> or <code>NESTED</code>). Here is an example that shows how to create a map and initialize it:</p><pre><code class="language-julia hljs">nside = 32
m = HealpixMap{Float64, RingOrder}(nside)
m.pixels[:] = 1.0  # Set all pixels to 1</code></pre><p>Healpix.jl defines the basic operations on maps (sum, subtraction, multiplication, division). These operations can either combine two maps or a map and a scalar value:</p><pre><code class="language-julia hljs">mollweide(m * 2.0)
mollweide(m * m)</code></pre><p>The <a href="#Healpix.HealpixMap"><code>HealpixMap{T, O &lt;: Order}</code></a> is derived from the abstract type <a href="#Healpix.AbstractHealpixMap"><code>AbstractHealpixMap{T}</code></a>, which does not encode the ordering. It is useful for functions that can either work on ring/nested-ordered maps but cannot be executed on plain generic arrays:</p><pre><code class="language-julia hljs"># Return the number of pixels in the map, regardless of its ordering
maplength(m::AbstractHealpixMap{T}) where T = length(m)

# This returns 12
maplength(HealpixMap{Float64, RingOrder}(1))

# This too returns 12
maplength(HealpixMap{Float64, NestedOrder}(1))

# This fails
maplength(zeros(Float64, 12))</code></pre><p>Healpix.jl implements the <a href="#Healpix.PolarizedHealpixMap"><code>PolarizedHealpixMap{T, O &lt;: Order}</code></a> type as well, which derives from <a href="#Healpix.AbstractPolarizedHealpixMap"><code>AbstractPolarizedHealpixMap{T}</code></a>. This encodes three maps containing the I/Q/U signal: the intensity (I), and the Q and U Stokes parameters. The three maps must have the same resolution.</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.AbstractHealpixMap" href="#Healpix.AbstractHealpixMap"><code>Healpix.AbstractHealpixMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractHealpixMap{T} &lt;: AbstractArray{T, 1}</code></pre><p>An abstract type representing an Healpix map without a specified ordering. This can be used to implement multiple dispatch when you don&#39;t care about the ordering of a map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.HealpixMap" href="#Healpix.HealpixMap"><code>Healpix.HealpixMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct HealpixMap{T, O &lt;: Order, AA &lt;: AbstractArray{T, 1}} &lt;: AbstractHealpixMap{T}</code></pre><p>A Healpix map. The type <code>T</code> is used for the value of the pixels in a map, and it can be anything (even a string!). The type <code>O</code> is used to specify the ordering of the pixels, and it can either be <code>RingOrder</code> or <code>NestedOrder</code>. The type <code>AA</code> is used to store the array of pixels; typical types are <code>Vector</code>, <code>CUArray</code>, <code>SharedArray</code>, etc.</p><p>A <code>HealpixMap</code> type contains the following fields:</p><ul><li><code>pixels</code>: array of pixels</li><li><code>resolution</code>: instance of a <code>Resolution</code> object</li></ul><p>You can construct a map using one of the following forms:</p><ul><li><p><code>HealpixMap{T, O, AA}(arr)</code> and <code>HealpixMap{T, O, AA}(nside::Number)</code> will use <code>AA</code> as basetype</p></li><li><p><code>HealpixMap{T, O}(arr)</code> and <code>HealpixMap{T, O}(nside::Number)</code> will use <code>Array{T, 1}</code> as basetype</p></li></ul><p><strong>Examples</strong></p><p>The following example creates a map with <code>NSIDE=32</code> in <code>RING</code> order, containing integer values starting from 1:</p><pre><code class="nohighlight hljs">mymap = Healpix.HealpixMap{Int64, Healpix.RingOrder}(1:Healpix.nside2npix(32))</code></pre><p>The call to <code>collect</code> is required to convert the range in an array.</p><p>This example creates a map in <code>NESTED</code> order, with <code>NSIDE=64</code>, filled with zeroes:</p><pre><code class="nohighlight hljs">mymap = Healpix.HealpixMap{Float64, Healpix.NestedOrder}(64)</code></pre><p>Finally, the following examples show how to use <code>SharedArray</code>:</p><pre><code class="nohighlight hljs">using SharedArrays

# Create a map with all pixels set to zero
mymap = Healpix.HealpixMap{Float64, Healpix.NestedOrder, SharedArray{Float64, 1}}(64)

# Create a map and initialize pixel values with a SharedArray
pixels = SharedArray{Int64, 1}(1:12 |&gt; collect)
mymap = Healpix.HealpixMap{Int64, Healpix.RingOrder, SharedArray{Int64, 1}}(m)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map.jl#L29-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.AbstractPolarizedHealpixMap" href="#Healpix.AbstractPolarizedHealpixMap"><code>Healpix.AbstractPolarizedHealpixMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPolarizedHealpixMap{T}</code></pre><p>An abstract type representing an Healpix polarized map without a specified ordering. This can be used to implement multiple dispatch when you don&#39;t care about the ordering of a map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/polarizedmap.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.PolarizedHealpixMap" href="#Healpix.PolarizedHealpixMap"><code>Healpix.PolarizedHealpixMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct PolarizedHealpixMap{T, O &lt;: Healpix.Order, AA &lt;: AbstractArray{T, 1}}</code></pre><p>A polarized I/Q/U map. It contains three Healpix maps with the same NSIDE:</p><ul><li><code>i</code></li><li><code>q</code></li><li><code>u</code></li></ul><p>You can create an instance of this type using the function <a href="#Healpix.PolarizedHealpixMap"><code>PolarizedHealpixMap{T,O}</code></a>, which comes in three flavours:</p><ul><li><code>PolarizedHealpixMap(i::HealpixMap{T,O,AA}, q::HealpixMap{T,O,AA}, u::HealpixMap{T,O,AA})</code></li><li><code>PolarizedHealpixMap{T,O}(i::AbstractVector{T}, q::AbstractVector{T}, u::AbstractVector{T})</code></li><li><code>PolarizedHealpixMap{T,O}(nside::Number)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/polarizedmap.jl#L13-L29">source</a></section></article><h2 id="Unseen-pixels-and-nothingness"><a class="docs-heading-anchor" href="#Unseen-pixels-and-nothingness">Unseen pixels and nothingness</a><a id="Unseen-pixels-and-nothingness-1"></a><a class="docs-heading-anchor-permalink" href="#Unseen-pixels-and-nothingness" title="Permalink"></a></h2><p>You can use the constant <a href="@ref"><code>UNSEEN</code></a> to mark unseen pixels, i.e., pixels that lack data associated with them, in a way that is compatible with other Healpix libraries.</p><pre><code class="language-julia hljs">m = HealpixMap{Float32, RingOrder}(32)

# Mark all the pixels in the map as «unseen» (missing)
m[:] .= UNSEEN</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12288-element view(::HealpixMap{Float32, RingOrder, Vector{Float32}}, :) with eltype Float32:
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30
  ⋮
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30
 -1.6375f30</code></pre><p>However, Julia provides a sounder way to denote missing pixels through the use of <code>Nothing</code> (type) and <code>nothing</code> (value). Whenever you pass a <code>Union{Nothing, T}</code> type to a Healpix map, the map will be initialized to <code>nothing</code>, and you can test if a pixel has been observer or not using Julia&#39;s function <code>isnothing</code>:</p><pre><code class="language-julia hljs">m = HealpixMap{Union{Int32, Nothing}, RingOrder}(1)

m[:] = 1:12
m[5] = nothing
@assert isnothing(m[5])</code></pre><p>Note that, unlike <a href="@ref"><code>UNSEEN</code></a>, this mechanism permits to signal «missing» pixels even for maps that do not use floating-point numbers.</p><div class="admonition is-warning"><header class="admonition-header">Reading/saving maps with `nothing` values</header><div class="admonition-body"><p>You can use <a href="#Healpix.saveToFITS"><code>saveToFITS</code></a> or <a href="#Healpix.readMapFromFITS"><code>readMapFromFITS</code></a> on maps whose base type is <code>Union{Nothing, T}</code> only if <code>T</code> is a floating-point number, because for the sake of compatibility with other Healpix libraries the FITS file will use <a href="@ref"><code>UNSEEN</code></a> to mark missing values.</p></div></div><h2 id="Encoding-the-order"><a class="docs-heading-anchor" href="#Encoding-the-order">Encoding the order</a><a id="Encoding-the-order-1"></a><a class="docs-heading-anchor-permalink" href="#Encoding-the-order" title="Permalink"></a></h2><p>Healpix.jl distinguishes between <code>RING</code> and <code>NEST</code> orderings using Julia&#39;s typesystem. The abstract type <code>Order</code> has two descendeants, <code>RingOrder</code> and <code>NestedOrder</code>, which are used to instantiate objects of type <code>HealpixMap</code>. Applying the functions <a href="#Healpix.nest2ring-Union{Tuple{HealpixMap{T, NestedOrder, AA}}, Tuple{AA}, Tuple{T}} where {T, AA}"><code>nest2ring</code></a> and  <a href="#Healpix.ring2nest-Union{Tuple{HealpixMap{T, RingOrder, AA}}, Tuple{AA}, Tuple{T}} where {T, AA}"><code>ring2nest</code></a> to maps converts those maps to the appropriate orders. In-place <a href="#Healpix.nest2ring!-Union{Tuple{AAR}, Tuple{AAN}, Tuple{T}, Tuple{HealpixMap{T, RingOrder, AAR}, HealpixMap{T, NestedOrder, AAN}}} where {T, AAN, AAR}"><code>nest2ring!</code></a> and <a href="#Healpix.ring2nest!-Union{Tuple{AAN}, Tuple{AAR}, Tuple{T}, Tuple{HealpixMap{T, NestedOrder, AAN}, HealpixMap{T, RingOrder, AAR}}} where {T, AAR, AAN}"><code>ring2nest!</code></a> versions are also  available.</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.Order" href="#Healpix.Order"><code>Healpix.Order</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type representing the ordering of pixels in a Healpix map. See also <code>RingOrder</code> and <code>NestedOrder</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map.jl#L4-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.RingOrder" href="#Healpix.RingOrder"><code>Healpix.RingOrder</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The <code>RingOrder</code> type should be used when creating <code>HealpixMap</code> types in order to specify that the pixels in the map are sorted in ring ordering. (See also <code>NestedOrder</code>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.NestedOrder" href="#Healpix.NestedOrder"><code>Healpix.NestedOrder</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The <code>NestedOrder</code> type should be used when creating <code>HealpixMap</code> types in order to specify that the pixels in the map are sorted in ring ordering. (See also <code>RingOrder</code>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.nest2ring-Union{Tuple{HealpixMap{T, NestedOrder, AA}}, Tuple{AA}, Tuple{T}} where {T, AA}" href="#Healpix.nest2ring-Union{Tuple{HealpixMap{T, NestedOrder, AA}}, Tuple{AA}, Tuple{T}} where {T, AA}"><code>Healpix.nest2ring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nest2ring(m_nest::HealpixMap{T, NestedOrder, AA}) where {T, AA}</code></pre><p>Convert a map from nested to ring order. This version allocates a new array of the same array type as the input.</p><p><strong>Arguments:</strong></p><ul><li><code>m_nest::HealpixMap{T, NestedOrder, AA}</code>: map of type <code>NestedOrder</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>HealpixMap{T, RingOrder, AA}</code>: the input map converted to <code>RingOrder</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m_nest = HealpixMap{Float64,NestedOrder}(rand(nside2npix(64)));

julia&gt; nest2ring(m_nest)
49152-element HealpixMap{Float64, RingOrder, Vector{Float64}}:
 0.4703834205807309
 ⋮
 0.3945848051663148</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map_pixelfunc.jl#L119-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.ring2nest-Union{Tuple{HealpixMap{T, RingOrder, AA}}, Tuple{AA}, Tuple{T}} where {T, AA}" href="#Healpix.ring2nest-Union{Tuple{HealpixMap{T, RingOrder, AA}}, Tuple{AA}, Tuple{T}} where {T, AA}"><code>Healpix.ring2nest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ring2nest(m_ring::HealpixMap{T, RingOrder, AA}) where {T, AA}</code></pre><p>Convert a map from ring to nested order. This version allocates a new array of the same array type as the input.</p><p><strong>Arguments:</strong></p><ul><li><code>m_ring::HealpixMap{T, RingOrder, AA}</code>: map of type <code>RingOrder</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>HealpixMap{T, NestedOrder, AA}</code>: the input map converted to <code>NestedOrder</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m_ring = HealpixMap{Float64,RingOrder}(rand(nside2npix(64)));

julia&gt; ring2nest(m_ring)
49152-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:
 0.0673134062168923
 ⋮
 0.703460503535335</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map_pixelfunc.jl#L187-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.nest2ring!-Union{Tuple{AAR}, Tuple{AAN}, Tuple{T}, Tuple{HealpixMap{T, RingOrder, AAR}, HealpixMap{T, NestedOrder, AAN}}} where {T, AAN, AAR}" href="#Healpix.nest2ring!-Union{Tuple{AAR}, Tuple{AAN}, Tuple{T}, Tuple{HealpixMap{T, RingOrder, AAR}, HealpixMap{T, NestedOrder, AAN}}} where {T, AAN, AAR}"><code>Healpix.nest2ring!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nest2ring!(m_ring_dst::HealpixMap{T, RingOrder, AAR}, 
           m_nest_src::HealpixMap{T, NestedOrder, AAN}) where {T, AAN, AAR}</code></pre><p>Convert a map from nested to ring order. This version takes a nested map in the  second argument and writes it to the nested map provided in the first argument, following the standard Julia <code>func!(dst, src)</code> convention.</p><p><strong>Arguments:</strong></p><ul><li><code>m_ring_dst::HealpixMap{T, NestedOrder, AA}</code>: map of type <code>NestedOrder</code></li><li><code>m_nest_src::HealpixMap{T, NestedOrder, AAN}</code>: map of type <code>RingOrder</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>HealpixMap{T, RingOrder, AA}</code>: the input map converted to <code>RingOrder</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m_nest = HealpixMap{Float64,NestedOrder}(rand(nside2npix(64)));

julia&gt; m_ring = HealpixMap{Float64,RingOrder}(64);

julia&gt; nest2ring!(m_ring, m_nest)
49152-element HealpixMap{Float64, RingOrder, Vector{Float64}}:
 0.33681791815569895
 ⋮
 0.9092457003948482</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map_pixelfunc.jl#L149-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.ring2nest!-Union{Tuple{AAN}, Tuple{AAR}, Tuple{T}, Tuple{HealpixMap{T, NestedOrder, AAN}, HealpixMap{T, RingOrder, AAR}}} where {T, AAR, AAN}" href="#Healpix.ring2nest!-Union{Tuple{AAN}, Tuple{AAR}, Tuple{T}, Tuple{HealpixMap{T, NestedOrder, AAN}, HealpixMap{T, RingOrder, AAR}}} where {T, AAR, AAN}"><code>Healpix.ring2nest!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ring2nest!(m_nest_dst::HealpixMap{T, NestedOrder, AAN}, 
           m_ring_src::HealpixMap{T, RingOrder, AAR}) where {T, AAR, AAN}</code></pre><p>Convert a map from ring to nested order. This version takes a nested map in the  second argument and writes it to the nested map provided in the first argument, following the standard Julia <code>func!(dst, src)</code> convention.</p><p><strong>Arguments:</strong></p><ul><li><code>m_nest_dst::HealpixMap{T, NestedOrder, AAN}</code>: map of type <code>RingOrder</code></li><li><code>m_ring_src::HealpixMap{T, RingOrder, AA}</code>: map of type <code>RingOrder</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>HealpixMap{T, NestedOrder, AA}</code>: the input map converted to <code>NestedOrder</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m_ring = HealpixMap{Float64,RingOrder}(rand(nside2npix(64)));

julia&gt; m_nest = HealpixMap{Float64,RingOrder}(64);

julia&gt; ring2nest!(m_nest, m_ring)
49152-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:
 0.0673134062168923
 ⋮
 0.703460503535335</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map_pixelfunc.jl#L217-L244">source</a></section></article><h2 id="Pixel-functions"><a class="docs-heading-anchor" href="#Pixel-functions">Pixel functions</a><a id="Pixel-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Pixel-functions" title="Permalink"></a></h2><p>When working with maps, it is not needed to pick between <a href="../pixelfunc/#Healpix.ang2pixNest-Tuple{Resolution, Any, Any}"><code>ang2pixNest</code></a> and <a href="../pixelfunc/#Healpix.ang2pixRing-Tuple{Resolution, Any, Any}"><code>ang2pixRing</code></a> because a <code>HealpixMap</code> type already encodes the ordering. Functions <code>pix2ang</code> and <code>ang2pix</code> always choose the correct ordering, but they require a <code>HealpixMap</code> instead of a <a href="../resolutions/#Healpix.Resolution"><code>Resolution</code></a> as their first argument.</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.pix2ang" href="#Healpix.pix2ang"><code>Healpix.pix2ang</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pix2ang{T, O &lt;: Order}(map::HealpixMap{T, O}, ipix) -&gt; (Float64, Float64)
pix2ang{T, O &lt;: Order}(map::PolarizedHealpixMap{T, O}, ipix) -&gt; (Float64, Float64)</code></pre><p>Return the pair (<code>theta</code>, <code>phi</code>), where <code>theta</code> is the colatitude and <code>phi</code> the longitude of the direction of the pixel center with index <code>ipix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map_pixelfunc.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.ang2pix" href="#Healpix.ang2pix"><code>Healpix.ang2pix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ang2pix{T, O, AA}(map::HealpixMap{T, O}, theta, phi)
ang2pix{T, O, AA}(map::PolarizedHealpixMap{T, O}, theta, phi)</code></pre><p>Convert the direction specified by the colatitude <code>theta</code> (∈ [0, π]) and the longitude <code>phi</code> (∈ [0, 2π]) into the index of the pixel in the Healpix map <code>map</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map_pixelfunc.jl#L12-L19">source</a></section></article><h2 id="Loading-and-saving-maps"><a class="docs-heading-anchor" href="#Loading-and-saving-maps">Loading and saving maps</a><a id="Loading-and-saving-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-and-saving-maps" title="Permalink"></a></h2><p>Healpix.jl implements a number of functions to save maps in FITS files.</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.saveToFITS" href="#Healpix.saveToFITS"><code>Healpix.saveToFITS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">saveToFITS(map::HealpixMap{T, O}, filename::AbstractString, typechar=&quot;D&quot;, unit=&quot;&quot;, extname=&quot;MAP&quot;) where {T &lt;: Number, O &lt;: Order}
saveToFITS(map::PolarizedHealpixMap{T, O}, filename::AbstractString, typechar=&quot;D&quot;, unit=&quot;&quot;, extname=&quot;MAP&quot;) where {T &lt;: Number, O &lt;: Order}</code></pre><p>Save a map into a FITS file. The name of the file is specified in <code>filename</code>; if it begins with <code>!</code>, existing files will be overwritten without warning. The parameter <code>typechar</code> specifies the data type to be used in the FITS file: the default (<code>D</code>) will save 64-bit floating-point values. See the CCFITSIO documentation for other values. The keyword <code>unit</code> specifies the measure unit used for the pixels in the map. The keyword <code>extname</code> specifies the name of the HDU where the map pixels will be written.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map_io.jl#L238-L251">source</a></section></article><p>Function <code>savePixelsToFITS</code> is a low-level function. It knows nothing about the ordering schema used for the pixels, so the caller should manually write the <code>ORDERING</code> keyword in the HDU header by itself.</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.savePixelsToFITS" href="#Healpix.savePixelsToFITS"><code>Healpix.savePixelsToFITS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">savePixelsToFITS(map::HealpixMap{T}, f::CFITSIO.FITSFile, column) where {T &lt;: Number}</code></pre><p>Save the pixels of <code>map</code> into the column with index/name <code>column</code> in the FITS file, which must have been already opened.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map_io.jl#L124-L129">source</a></section></article><p>To load a map from a FITS file, you can either use <a href="#Healpix.readMapFromFITS"><code>readMapFromFITS</code></a> or <a href="#Healpix.readPolarizedMapFromFITS"><code>readPolarizedMapFromFITS</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.readMapFromFITS" href="#Healpix.readMapFromFITS"><code>Healpix.readMapFromFITS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readMapFromFITS{T}(f::CFITSIO.FITSFILE, column, t::Type{T})
readMapFromFITS{T}(fileName::String, column, t::Type{T})</code></pre><p>Read a Healpix map from the specified (1-base indexed) column in a FITS file. The values will be read as numbers of type T. If the code fails, CFITSIO will raise an exception. (Refer to the CFITSIO library for more information.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map_io.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.readPolarizedMapFromFITS" href="#Healpix.readPolarizedMapFromFITS"><code>Healpix.readPolarizedMapFromFITS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readPolarizedMapFromFITS{T}(fileName::AbstractString, column, t::Type{T})</code></pre><p>Read a polarized map (I/Q/U) from a FITS file and return a <a href="#Healpix.PolarizedHealpixMap"><code>PolarizedHealpixMap</code></a> object.</p><p>The parameter <code>column</code> can be either a number or a 3-element tuple. In the first case, three consecutive columns will be read starting from <code>column</code> (1-based index), otherwise the three column indices will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map_io.jl#L76-L86">source</a></section></article><h2 id="Testing-for-conformability"><a class="docs-heading-anchor" href="#Testing-for-conformability">Testing for conformability</a><a id="Testing-for-conformability-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-for-conformability" title="Permalink"></a></h2><p>It often happens that two Healpix maps need to be combined together: for instance, pixels on a sky map might need to be masked using a sky mask, or one map might need to be subtracted from another one. «Conformability» means that the operation between the two maps can be done directly on the pixels, without oordering or resolution conversions. The function <code>conformables</code> checks this.</p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m1 = HealpixMap{Float64, RingOrder}(1)</code><code class="nohighlight hljs ansi" style="display:block;">12-element HealpixMap{Float64, RingOrder, Vector{Float64}}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m2 = HealpixMap{Float64, RingOrder}(1)</code><code class="nohighlight hljs ansi" style="display:block;">12-element HealpixMap{Float64, RingOrder, Vector{Float64}}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m3 = HealpixMap{Float64, NestedOrder}(1)</code><code class="nohighlight hljs ansi" style="display:block;">12-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m4 = HealpixMap{Float64, NestedOrder}(2)</code><code class="nohighlight hljs ansi" style="display:block;">48-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 ⋮
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conformables(m1, m2)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conformables(m1, m3)</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conformables(m1, m4)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><article class="docstring"><header><a class="docstring-binding" id="Healpix.conformables" href="#Healpix.conformables"><code>Healpix.conformables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conformables{T, S, O1, O2}(map1::HealpixMap{T, O1, AA1},
                           map2::HealpixMap{S, O2, AA2}) -&gt; Bool
conformables{T, S, O1, O2}(map1::PolarizedHealpixMap{T, O1, AA1},
                           map2::PolarizedHealpixMap{S, O2, AA2}) -&gt; Bool</code></pre><p>Determine if two Healpix maps are &quot;conformables&quot;, i.e., if their shape and ordering are the same. The array types <code>AA1</code> and <code>AA2</code> are not considered in testing conformability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/conformables.jl#L30-L39">source</a></section></article><h2 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h2><p>The fact that a Healpix map is, well, pixelized means that there is a sharp boundary between adjacent pixels. This can lead to undesidable effects, and therefore Healpix.jl provides a function, <a href="#Healpix.interpolate"><code>interpolate</code></a>, that returns the interpolated value of the map along some direction in the sky:</p><ul><li>If the direction (θ, ɸ) passes through the center of a pixel, <code>interpolate</code> returns the value of the pixel itself;</li><li>Otherwise, the value of the pixel and its neighbours will be interpolated using a linear function to return a weighted value.</li></ul><article class="docstring"><header><a class="docstring-binding" id="Healpix.interpolate" href="#Healpix.interpolate"><code>Healpix.interpolate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolate(m::HealpixMap{T, RingOrder, AA}, θ, ϕ) -&gt; Value
interpolate(m::HealpixMap{T, RingOrder, AA}, θ, ϕ, pixbuf, weightbuf) -&gt; Value</code></pre><p>Return an interpolated value of the map along the specified direction.</p><p>When provided, the parameters <code>pixbuf</code> and <code>weightbuf</code> must be 4-element arrays of integer and floating-point values, respectively. They can be reused across multiple calls of <code>interpolate</code>, to save heap allocations, and they do not need to be initialized, as they are used internally:</p><pre><code class="nohighlight hljs">pixbuf = Array{Int}(undef, 4)
weightbuf = Array{Float64}(undef, 4)

m = HealpixMap{Float64, RingOrder}(1)
for (θ, ϕ) in [(0., 0.), (π/2, π/2)]
    println(interpolate(m, θ, ϕ, pixbuf, weightbuf))
end</code></pre><p>Passing <code>pixbuf</code> and <code>weightbuf</code> saves some time, as this simple benchmark shows:</p><pre><code class="nohighlight hljs">julia&gt; @benchmark interpolate(m, rand(), rand(), pixbuf, weightbuf)
BenchmarkTools.Trial: 
  memory estimate:  618 bytes
  allocs estimate:  9
  --------------
  minimum time:     283.184 ns (0.00% GC)
  median time:      296.140 ns (0.00% GC)
  mean time:        348.132 ns (9.55% GC)
  maximum time:     10.627 μs (95.88% GC)
  --------------
  samples:          10000
  evals/sample:     282

julia&gt; @benchmark interpolate(m, rand(), rand())
BenchmarkTools.Trial: 
  memory estimate:  837 bytes
  allocs estimate:  11
  --------------
  minimum time:     329.825 ns (0.00% GC)
  median time:      345.504 ns (0.00% GC)
  mean time:        417.004 ns (11.04% GC)
  maximum time:     13.733 μs (96.21% GC)
  --------------
  samples:          10000
  evals/sample:     223</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map_pixelfunc.jl#L62-L115">source</a></section></article><h2 id="Upgrading-and-Downgrading"><a class="docs-heading-anchor" href="#Upgrading-and-Downgrading">Upgrading and Downgrading</a><a id="Upgrading-and-Downgrading-1"></a><a class="docs-heading-anchor-permalink" href="#Upgrading-and-Downgrading" title="Permalink"></a></h2><p>Changing resolution is done with <a href="#Healpix.udgrade"><code>udgrade</code></a>. This is very fast for nested orderings, but slow for ring ordering.</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.udgrade" href="#Healpix.udgrade"><code>Healpix.udgrade</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">udgrade(input_map::HealpixMap{T,O,AA}, output_nside; kw...) where {T,O,AA} -&gt; HealpixMap{T,O,AA}</code></pre><p>Upgrades or downgrades a map to a target nside. Always makes a copy. This is very fast  for nested orderings, but slow for ring because one needs to transform to nested ordering  first.</p><p><strong>Arguments:</strong></p><ul><li><code>input_map::HealpixMap{T,O,AA}</code>: the map to upgrade/downgrade</li><li><code>output_nside</code>: desired nside</li></ul><p><strong>Keywords:</strong></p><ul><li><code>threshold=abs(1e-6UNSEEN)</code>: absolute tolerance for identifying a bad pixel vs UNSEEN</li><li><code>pess=false</code>: if false, estimate pixels from remaining good pixels when downgrading.    if true, the entire downgraded pixel is set to UNSEEN.</li></ul><p><strong>Returns:</strong></p><ul><li><code>HealpixMap{T,O,AA}</code>: upgraded/downgraded map in the same ordering as the input</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = HealpixMap{Float64, NestedOrder}(ones(nside2npix(4)))
192-element HealpixMap{Float64, RingOrder, Vector{Float64}}:
 1.0
 ⋮
 1.0

julia&gt; Healpix.udgrade(A, 2)
48-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:
 1.0
 ⋮
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/map_pixelfunc.jl#L255-L288">source</a></section></article><h2 id="Map-making"><a class="docs-heading-anchor" href="#Map-making">Map-making</a><a id="Map-making-1"></a><a class="docs-heading-anchor-permalink" href="#Map-making" title="Permalink"></a></h2><p>Map-making is the process of converting a time series of measurements into a sky map. The most basic form of map-making is the so-called &quot;binning&quot;, where samples in the time stream falling within the same sky pixel are averaged. This map-making algorithm is strictly accurate only if the noise in the time stream is white.</p><p>Healpix.jl implements two functions to perform binning, <a href="#Healpix.tod2map"><code>tod2map</code></a> and <a href="#Healpix.combinemaps!"><code>combinemaps!</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Healpix.tod2map" href="#Healpix.tod2map"><code>Healpix.tod2map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tod2map{T,O}(pixidx, tod::Array{T}; nside=128) :: (map, hits)</code></pre><p>Create a binned map for a TOD and return a tuple containing the map itself and the hit map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/mapmaking.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Healpix.combinemaps!" href="#Healpix.combinemaps!"><code>Healpix.combinemaps!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combinemaps{T, O, H}(destmap::HealpixMap{T, O}, desthitmap::HealpixMap{H, O}, othermap::HealpixMap{T, O}, otherhitmap::HealpixMap{H, O})</code></pre><p>Sum &quot;othermap&quot; to &quot;destmap&quot;, assuming that both maps have been produced by binning TODs. The parameters <code>desthitmap</code> and <code>otherhitmap</code> are the two hit maps. At the end of the call, <code>destmap</code> and <code>desthitmap</code> are updated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/5b716f5721e4f40ec1cbf78b8696b337673630cb/src/mapmaking.jl#L31-L38">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pixelfunc/">« Pixel functions</a><a class="docs-footer-nextpage" href="../alm/">Spherical harmonics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 9 December 2021 13:34">Thursday 9 December 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
