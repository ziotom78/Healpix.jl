<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Spherical harmonics · Healpix.jl</title><meta name="title" content="Spherical harmonics · Healpix.jl"/><meta property="og:title" content="Spherical harmonics · Healpix.jl"/><meta property="twitter:title" content="Spherical harmonics · Healpix.jl"/><meta name="description" content="Documentation for Healpix.jl."/><meta property="og:description" content="Documentation for Healpix.jl."/><meta property="twitter:description" content="Documentation for Healpix.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Healpix.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../resolutions/">Working with resolutions</a></li><li><a class="tocitem" href="../pixelfunc/">Pixel functions</a></li><li><a class="tocitem" href="../query/">Query functions</a></li><li><a class="tocitem" href="../mapfunc/">Map functions</a></li><li class="is-active"><a class="tocitem" href>Spherical harmonics</a><ul class="internal"><li><a class="tocitem" href="#Converting-between-pixel-space-and-harmonic-space"><span>Converting between pixel space and harmonic space</span></a></li><li><a class="tocitem" href="#From-harmonic-coefficients-to-the-power-spectrum"><span>From harmonic coefficients to the power spectrum</span></a></li><li><a class="tocitem" href="#Algebraic-operations-in-harmonic-space"><span>Algebraic operations in harmonic space</span></a></li><li><a class="tocitem" href="#Loading-and-saving-harmonic-coefficients"><span>Loading and saving harmonic coefficients</span></a></li><li><a class="tocitem" href="#Alm-Indexing"><span>Alm Indexing</span></a></li><li><a class="tocitem" href="#Full-Pixel-Weights"><span>Full Pixel Weights</span></a></li></ul></li><li><a class="tocitem" href="../Cl/">Power Spectrum</a></li><li><a class="tocitem" href="../visualization/">Visualization</a></li><li><a class="tocitem" href="../misc/">Miscellanea</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Spherical harmonics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Spherical harmonics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ziotom78/Healpix.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ziotom78/Healpix.jl/blob/master/docs/src/alm.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Spherical-harmonics"><a class="docs-heading-anchor" href="#Spherical-harmonics">Spherical harmonics</a><a id="Spherical-harmonics-1"></a><a class="docs-heading-anchor-permalink" href="#Spherical-harmonics" title="Permalink"></a></h1><p>Starting from version 2.4, Healpix.jl implements generalized Fourier transformations through the <code>libsharp</code> library, to convert a map from its pixel-space representation to its decomposition in spherical harmonics. This has multiple applications, the most relevant being the analysis of Cosmic Microwave Background maps and the efficient computation of convolution operators.</p><p>Everything revolves around the <a href="#Healpix.Alm"><code>Alm</code></a> type, which encodes a set of spherical harmonics and is thus conceptually equivalent to the concept of a <a href="../mapfunc/#Healpix.HealpixMap"><code>HealpixMap</code></a>, only living in the harmonic space:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.Alm" href="#Healpix.Alm"><code>Healpix.Alm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Alm{T &lt;: Number, AA &lt;: AbstractVector{T}}</code></pre><p>An array of harmonic coefficients (a_ℓm).</p><p>The type <code>T</code> is used for the value of each harmonic coefficient, and it must be a <code>Number</code> (one should however only use complex types for this). The type <code>AA</code> is used to store the array of coefficients; a typical choice is <code>Vector</code>.</p><p>A <code>Alm</code> type contains the following fields:</p><ul><li><code>alm</code>: the array of harmonic coefficients</li><li><code>lmax</code>: the maximum value for <span>$ℓ$</span></li><li><code>mmax</code>: the maximum value for <span>$m$</span></li><li><code>tval</code>: maximum number of <span>$m$</span> coefficients for the maximum <span>$ℓ$</span></li></ul><p>The <span>$a_{ℓm}$</span> are stored by <span>$m$</span>: if <span>$ℓ_{max}$</span> is 16, the first 16 elements are <span>$m=0$</span>, <span>$ℓ=0-16$</span>, then the following 15 elements are <span>$m=1$</span>, <span>$ℓ=1-16$</span>, then <span>$m=2$</span>, <span>$ℓ=2-16$</span> and so on until the last element, the 153th, is <span>$m=16$</span>, <span>$ℓ=16$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L3-L23">source</a></section></article><p>In the general case, the number of coefficients in a spherical harmonic expansion is infinite. For obvious reasons, Healpix.jl only allows to store band-limited expansions. The function <a href="#Healpix.numberOfAlms"><code>numberOfAlms</code></a> returns the number of floating-point numbers used to store the expansion, as a function of the maximum value for <span>$\ell$</span> and <span>$m$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.numberOfAlms" href="#Healpix.numberOfAlms"><code>Healpix.numberOfAlms</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">numberOfAlms(lmax::Integer, mmax::Integer) -&gt; Integer
numberOfAlms(lmax::Integer) -&gt; Integer</code></pre><p>Return the size of the array of complex numbers needed to store the a_ℓm coefficients in the range of ℓ and m specified by <code>lmax</code> and <code>mmax</code>. If <code>mmax</code> is not specified, it is assumed to be equal to <code>lmax</code>. If <code>lmax</code> and <code>mmax</code> are inconsistent or negative, a <code>DomainError</code> exception is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L47-L56">source</a></section></article><h2 id="Converting-between-pixel-space-and-harmonic-space"><a class="docs-heading-anchor" href="#Converting-between-pixel-space-and-harmonic-space">Converting between pixel space and harmonic space</a><a id="Converting-between-pixel-space-and-harmonic-space-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-between-pixel-space-and-harmonic-space" title="Permalink"></a></h2><p>Healpix.jl implements the four functions <a href="#Healpix.alm2map"><code>alm2map</code></a>, <a href="#Healpix.map2alm"><code>map2alm</code></a>, <a href="#Healpix.alm2map!"><code>alm2map!</code></a>, and <a href="#Healpix.map2alm!"><code>map2alm!</code></a> to convert a map from a pixel-space representation to the harmonic space and vice-versa. The functions ending with <code>!</code> are <em>mutating</em> functions, which means that they assume that the result must be saved in a preallocated variable; they are space- and time-efficient and should be used when you want your code to be performant, or when you plan to apply the same operation several times (e.g., in a Monte Carlo simulation). The synthesis operation (<a href="#Healpix.alm2map"><code>alm2map</code></a>) is generally referred to with the matrix operator <span>$\mathrm{Y}$</span>, while his inverse (<a href="#Healpix.map2alm"><code>map2alm</code></a>) with <span>$\mathrm{Y}^{-1}$</span>.</p><p>Healpix.jl also implements the two adjoint functions <a href="#Healpix.adjoint_alm2map!"><code>adjoint_alm2map!</code></a> and <a href="#Healpix.adjoint_map2alm!"><code>adjoint_map2alm!</code></a>, represented by <span>$\mathrm{Y}^{\mathrm{T}}$</span> and <span>$(\mathrm{Y}^{-1})^\mathrm{T}$</span> respectively. While the synthesis operator on a general scalar field <span>$f(θ, φ)$</span> can be defined through an exact summation as <span>$f(θ, φ) = \mathrm{Y} \, a_{ℓm}$</span> where <span>$f(θ, φ) = \sum_{ℓ=0}^∞ \sum_{m=-ℓ}^ℓ a_{ℓm} Y_{ℓm}(θ, φ)$</span>. The analysis operator is defined through an integral operator as <span>$a_{ℓm} = \mathrm{Y}^{-1} f(θ, φ)$</span> where <span>$a_{ℓm} = \int_0^{2π} \int_0^π Y_{ℓm}^*(θ, φ)\, f(θ, φ) \sin θ \, dθ \, dφ$</span>. Though, in the real case wherein maps are pixelized, the latter ends up being approximated through a summation over the pixels. Here is where the adjoint of the synthesis operator, <span>$\mathrm{Y}^{\mathrm{T}}$</span>, comes into play. It is defined through: <span>$\mathrm{Y}^{\mathrm{T}} f(θ, φ) \equiv \sum_{i=1}^{N_{\mathrm{pix}}} Y_{ℓm,\,i}^* \, f_i,$</span> which is an exact operation. Note that the latter does not give directly the <span>$a_{\ell m}$</span> coefficients, since <span>$\mathrm{Y}^{-1} \simeq \mathrm{W}\, \mathrm{Y}^{\mathrm{T}}$</span>, where <span>$\mathrm{W}$</span> is a diagonal matrix whose non-zero elements are approximately constant and equal to <span>$4π / N_{\mathrm{pix}}$</span>, depending on the map pixelization. The latter realtion is also useful to obtain the adjoint of the analysis operator: <span>$(\mathrm{Y}^{-1})^\mathrm{T} = \mathrm{W}^{\mathrm{T}}\,\mathrm{Y} =  \mathrm{W}\,\mathrm{Y}$</span>.</p><p>Here is an example:</p><pre><code class="language-julia hljs">using Random

# Ensure reproducibility by using a fixed seed
Random.seed!(1234)

nside = 8
m = HealpixMap{Float32,RingOrder}(nside)

# Initialize the pixels to random values in the 0…1 range
for i in 1:length(m)
    m[i] = rand(Float32)
end

alm = map2alm(m)

# Go back to pixel space
newm = alm2map(alm, nside)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">768-element HealpixMap{Float64, RingOrder, Vector{Float64}}:
 0.4334681110199904
 0.46760588403582776
 0.2356189978218053
 0.7677461691857397
 0.26188278236087537
 0.438393398270254
 0.9302889363247367
 0.8597877691283009
 0.6675362959627755
 0.5961908196786236
 ⋮
 0.40445452823379824
 0.8160867498711573
 0.6332998058370749
 0.612791914793216
 0.4012637841276252
 0.19598229849597731
 0.6998262769237045
 0.8132148132630672
 0.43815195983473854</code></pre><p>The variable <code>newm</code> is a map that is close enough to <code>m</code>, yet it is not exactly the same because of the approximations done by both <code>map2alm</code> and <code>alm2map</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.map2alm!" href="#Healpix.map2alm!"><code>Healpix.map2alm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map2alm!(map::HealpixMap{Float64, RingOrder, Vector{Float64}},
         alm::Alm{ComplexF64, Vector{ComplexF64}};
         niter::Integer=3)
map2alm!(map::PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}},
         alm::Vector{Alm{ComplexF64, Vector{ComplexF64}}};
         niter::Integer=3)</code></pre><p>This function performs a spherical harmonic transform on the map and places the results in the passed <code>alm</code> object. This function requires types derived from Float64, since it is done in-place.</p><p><strong>Arguments</strong></p><ul><li><p><code>map</code>: the map that must be decomposed in spherical harmonics. It can either be a <code>HealpixMap{Float64, RingOrder}</code> type (scalar map) or a <code>PolarizedHealpixMap{Float64, RingOrder}</code> type (polarized map).</p></li><li><p><code>alm::Alm{ComplexF64, Vector{ComplexF64}}</code>: the spherical harmonic coefficients to be written to.</p></li></ul><p><strong>Keywords</strong></p><ul><li><code>niter::Integer</code>: number of iterations of SHTs to perform, to enhance accuracy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/sphtfunc.jl#L74-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.map2alm" href="#Healpix.map2alm"><code>Healpix.map2alm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map2alm(map::HealpixMap{Float64, RingOrder, AA};
        lmax=nothing, mmax=nothing, niter::Integer=3)
map2alm(m::HealpixMap{T, RingOrder, AA};
        lmax=nothing, mmax=nothing,
        niter::Integer=3) where {T &lt;: Real, AA &lt;: AbstractVector{T}}</code></pre><p>Compute the spherical harmonic coefficients of a map. To enhance precision, more iterations of the transforms can be performed by passing a nonzero <code>niter</code>. The underlying SHT library libsharp performs all calculations using <code>Cdouble</code> types, so all inputs are converted to types based on Float64.</p><p><strong>Arguments</strong></p><ul><li><code>map</code>: the map to decompose in spherical harmonics. It can either be a <code>HealpixMap{T, RingOrder, AA}</code> type (scalar map) or a <code>PolarizedHealpixMap{T, RingOrder, AA}</code> type (polarized map).</li></ul><p><strong>Keywords</strong></p><ul><li><p><code>lmax::Integer</code>: the maximum ℓ coefficient, will default to 3*nside-1 if not specified.</p></li><li><p><code>mmax::Integer</code>: the maximum m coefficient</p></li><li><p><code>niter::Integer</code>: number of SHT iterations, to enhance precision. Defaults to 3</p></li></ul><p><strong>Returns</strong></p><ul><li><code>Alm{ComplexF64, Vector{ComplexF64}}</code>: the spherical harmonic coefficients corresponding to the map</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/sphtfunc.jl#L161-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.alm2map!" href="#Healpix.alm2map!"><code>Healpix.alm2map!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alm2map!(alm::Alm{ComplexF64, Vector{ComplexF64}},
         map::HealpixMap{Float64, RingOrder, Vector{Float64}})
alm2map!(alm::Vector{Alm{ComplexF64, Vector{ComplexF64}}},
         map::PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}})</code></pre><p>This function performs a spherical harmonic transform on the map and places the results in the passed <code>alm</code> object. This function requires types derived from Float64, since it is done in-place.</p><p><strong>Arguments</strong></p><ul><li><p><code>alm::Alm{ComplexF64, Vector{ComplexF64}}</code>: the spherical harmonic coefficients to perform the spherical harmonic transform on.</p></li><li><p><code>map</code>: the map that will contain the result. It can either be a <code>HealpixMap{Float64, RingOrder, Vector{Float64}}</code> type (scalar map) or a <code>PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}}</code> (polarized map).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/sphtfunc.jl#L331-L350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.alm2map" href="#Healpix.alm2map"><code>Healpix.alm2map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alm2map(alm::Alm{ComplexF64, Vector{Float64}}, nside::Integer)
alm2map(alm::Alm{T, Vector{T}}, nside::Integer) where T
alm2map(alm::Vector{Alm{ComplexF64, Vector{ComplexF64}}}, nside::Integer)
alm2map(alms::Vector{Alm{T, Vector{T}}}, nside::Integer) where T</code></pre><p>Compute a map from spherical harmonic coefficients. The underlying SHT library libsharp performs all calculations in Cdouble, so all inputs are converted to types based on Float64.</p><p><strong>Arguments</strong></p><ul><li><code>alm</code>: the spherical harmonic coefficients to transform. If of type <code>Alm{T, Vector{T}}</code>, we assume a spin-0 spherical harmonic transform. If an array of <code>Alm</code> is passed, we assume that the components correspond to T, E, and B coefficients.</li></ul><p><strong>Keywords</strong></p><ul><li><code>nside::Integer</code>: Healpix resolution parameter</li></ul><p><strong>Returns</strong></p><ul><li><code>HealpixMap{Float64, RingOrder, Vector{Float64}}</code> or <code>PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}}</code> depending on if the input alm is of type <code>Alm{T, Vector{T}}</code> or <code>Array{Alm{T,Vector{T}}}</code> respectively.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/sphtfunc.jl#L401-L427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.adjoint_alm2map!" href="#Healpix.adjoint_alm2map!"><code>Healpix.adjoint_alm2map!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjoint_alm2map!(map::HealpixMap{Float64, RingOrder, Vector{Float64}},
                 alm::Alm{ComplexF64, Vector{ComplexF64}})
adjoint_alm2map!(map::PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}},
                 alm::Vector{Alm{ComplexF64, Vector{ComplexF64}}})</code></pre><p>This function performs a spherical harmonic transform Yᵀ on the map and places the results in the passed <code>alm</code> object. This function requires types derived from Float64, since it is done in-place.</p><p><strong>Arguments</strong></p><ul><li><p><code>map</code>: the map that must be decomposed in spherical harmonics. It can either be a <code>HealpixMap{Float64, RingOrder}</code> type (scalar map) or a <code>PolarizedHealpixMap{Float64, RingOrder}</code> type (polarized map).</p></li><li><p><code>alm::Alm{ComplexF64, Vector{ComplexF64}}</code>: the spherical harmonic coefficients to be written to.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/sphtfunc.jl#L475-L493">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.adjoint_map2alm!" href="#Healpix.adjoint_map2alm!"><code>Healpix.adjoint_map2alm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjoint_map2alm!(alm::Alm{ComplexF64, Vector{ComplexF64}},
                 map::HealpixMap{Float64, RingOrder, Vector{Float64}})
adjoint_map2alm!(alm::Vector{Alm{ComplexF64, Vector{ComplexF64}}},
                 map::PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}})</code></pre><p>This function performs the spherical harmonic transform (Y^-1)^t = W^t Y = W Y on the map and places the results in the passed <code>alm</code> object. This function requires types derived from Float64, since it is done in-place.</p><p><strong>Arguments</strong></p><ul><li><p><code>alm::Alm{ComplexF64, Vector{ComplexF64}}</code>: the spherical harmonic coefficients to perform the spherical harmonic transform on.</p></li><li><p><code>map</code>: the map that will contain the result. It can either be a <code>HealpixMap{Float64, RingOrder, Vector{Float64}}</code> type (scalar map) or a <code>PolarizedHealpixMap{Float64, RingOrder, Vector{Float64}}</code> (polarized map).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/sphtfunc.jl#L262-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.iterate_map2alm!" href="#Healpix.iterate_map2alm!"><code>Healpix.iterate_map2alm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterate_map2alm!(
    maps::Vector{Vector{Float64}}, alms::Vector{Vector{Complex{Float64}}},
    geom_info::Libsharp.GeomInfo, alm_info::Libsharp.AlmInfo,
    niter::Integer, spin::Integer)</code></pre><p>This is an internal function for implementing iterative map2alm, used when the parameter <code>niter</code> is greater than 0. It synthesizes a map from the alms, subtracts it from the map to form a residual map, and then adds the harmonic coefficients of the residual map to the alms. It repeats this <code>niter</code> times. It performs this in-place on arrays of Float64 and Complex{Float64}.</p><p><strong>Arguments</strong></p><ul><li><p><code>maps::Vector{Vector{Float64}}</code>: an array where each element is a 1D Healpix map array.</p></li><li><p><code>alms::Vector{Vector{Complex{Float64}}}</code>: an array where each element is a array of alms</p></li><li><p><code>geom_info::Libsharp.GeomInfo</code>: contains information about the pixelization</p></li><li><p><code>alm_info::Libsharp.AlmInfo</code>: contains information about the SHT coefficient ordering</p></li><li><p><code>niter::Integer</code>: number of iterations to perform</p></li><li><p><code>spin::Integer</code>: spin of the field, 0 or 2</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/sphtfunc.jl#L3-L28">source</a></section></article><h2 id="From-harmonic-coefficients-to-the-power-spectrum"><a class="docs-heading-anchor" href="#From-harmonic-coefficients-to-the-power-spectrum">From harmonic coefficients to the power spectrum</a><a id="From-harmonic-coefficients-to-the-power-spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#From-harmonic-coefficients-to-the-power-spectrum" title="Permalink"></a></h2><p>You can use the function <a href="#Healpix.alm2cl"><code>alm2cl</code></a> to convert a set of <span>$a_{\ell m}$</span> coefficients into the components <span>$C_\ell$</span> of the power spectrum. The pixelization also induces a transfer function, which can be obtained from <a href="#Healpix.pixwin"><code>pixwin</code></a>. A simple Gaussian beam window function in the asymptotic small-beam limit can be computed with <a href="#Healpix.gaussbeam"><code>gaussbeam</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.alm2cl" href="#Healpix.alm2cl"><code>Healpix.alm2cl</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alm2cl(alm::Alm{Complex{T}}) where {T &lt;: Number} -&gt; Vector{T}
alm2cl(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T &lt;: Number} -&gt; Vector{T}</code></pre><p>Compute <span>$C_ℓ$</span> from the spherical harmonic coefficients of one or two fields.</p><p><strong>Arguments</strong></p><ul><li><code>alm₁::Alm{Complex{T}}</code>: the spherical harmonic coefficients of the first field</li><li><code>alm₂::Alm{Complex{T}}</code>: the spherical harmonic coefficients of the second field</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{T}</code> containing <span>$C_ℓ$</span>, with the first element referring to ℓ=0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L295-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.pixwin" href="#Healpix.pixwin"><code>Healpix.pixwin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pixwin(nside; pol=false)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>nside</code>: HEALPix resolution parameter</li></ul><p><strong>Keywords</strong></p><ul><li><code>pol::Bool=false</code>: if true, also return polarization pixel window</li></ul><p><strong>Returns:</strong></p><ul><li><code>Vector{Float64}</code> pixel window function. If <code>pol=true</code>, returns a Tuple   of the temperature and polarization pixel windows.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pixwin(4)
17-element Vector{Float64}:
 1.0000000000020606
 0.9942340766588788
 ⋮
 0.4222841034207188</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/sphtfunc.jl#L545-L567">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.gaussbeam" href="#Healpix.gaussbeam"><code>Healpix.gaussbeam</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussbeam(fwhm::T, lmax::Int; pol=false) where T</code></pre><p>Compute the Gaussian beam window function <span>$B_ℓ$</span> given the FWHM of the beam in radians, where <span>$C_{ℓ, \mathrm{measured}} = B_ℓ^2 C_ℓ$</span>. This beam is valid in the limit of <span>$σ^2 \ll 0$</span>, which is the case for all high-resolution CMB experiments.</p><p><strong>Arguments</strong></p><ul><li><code>fwhm::T</code>: FWHM of the Gaussian beam in radians</li><li><code>lmax::Int</code>: maximum multipole ℓ</li><li><code>pol=false</code>: if false, returns the spin-0 beam for i.e. intensity. if true, returns the spin-2 beam</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{T}</code> containing <span>$B_ℓ$</span>, with the first element referring to ℓ=0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L334-L348">source</a></section></article><h2 id="Algebraic-operations-in-harmonic-space"><a class="docs-heading-anchor" href="#Algebraic-operations-in-harmonic-space">Algebraic operations in harmonic space</a><a id="Algebraic-operations-in-harmonic-space-1"></a><a class="docs-heading-anchor-permalink" href="#Algebraic-operations-in-harmonic-space" title="Permalink"></a></h2><p>Healpix.jl provides overloads of the <code>Base</code> functions <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, as well as <code>LinearAlgebra.dot</code>, allowing to carry out these fundamental operations element-wise in harmonic space directly.</p><p>For example, an element-wise sum between two <code>Alm</code> objects can be performed as follows:</p><pre><code class="language-julia hljs">using Healpix

#just two constant Alm objects
myalm1 = Healpix.Alm(5,5, ones(ComplexF64, Healpix.numberOfAlms(5)))
myalm1 = Healpix.Alm(5,5, ones(ComplexF64, Healpix.numberOfAlms(5)))

alm_sum = myalm1 + myalm2 #each element will be = 2 + 0im</code></pre><h4 id="Multiplying-or-dividing-a-set-of-Alm-by-a-generic-function-of-ℓ-or-a-constant"><a class="docs-heading-anchor" href="#Multiplying-or-dividing-a-set-of-Alm-by-a-generic-function-of-ℓ-or-a-constant">Multiplying or dividing a set of Alm by a generic function of ℓ or a constant</a><a id="Multiplying-or-dividing-a-set-of-Alm-by-a-generic-function-of-ℓ-or-a-constant-1"></a><a class="docs-heading-anchor-permalink" href="#Multiplying-or-dividing-a-set-of-Alm-by-a-generic-function-of-ℓ-or-a-constant" title="Permalink"></a></h4><p>The operators <code>*</code> and <code>/</code> can be used to multiply or divide an <code>Alm</code> by an <span>$ℓ$</span>-dependent generic function <span>$f_\ell$</span> (or just a constant, of type <code>Number</code>).</p><p>In this case a new instance of <code>Alm</code> type will be returned. To perform a more efficient in-place operation refer to <a href="#Healpix.almxfl!"><code>almxfl!</code></a>, as shown in this brief example:</p><pre><code class="language-julia hljs">using Healpix

#just two constant Alm objects
myalm = Healpix.Alm(5,5, ones(ComplexF64, Healpix.numberOfAlms(5)))
myf_l = ones(Healpix.numberOfAlms(5)) .* 2

#will return a new object:
myalm*myf_l
myalm/myf_l

#will overwrite myalm:
almxfl!(myalm, myf_l)
almxfl!(myalm, 1.0 ./ myf_l) #division</code></pre><p>In either case the call to such operator consists in a shortcut to the function <a href="#Healpix.almxfl"><code>almxfl</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.almxfl" href="#Healpix.almxfl"><code>Healpix.almxfl</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">almxfl(alm::Alm{Complex{T}}, fl::AbstractVector{T}) where {T &lt;: Number} -&gt; Alm{T}</code></pre><p>Multiply an a<em>ℓm by a vector b</em>ℓ representing an ℓ-dependent function, without changing the a_ℓm passed in input.</p><p><strong>Arguments</strong></p><ul><li><code>alms::Alm{Complex{T}}</code>: The <code>Alm</code> object containing the spherical harmonics coefficients</li><li><code>fl::AbstractVector{T}</code>: The array containing the factors f<em>ℓ to be multiplied by a</em>ℓm</li></ul><p><strong>Returns</strong></p><ul><li><code>Alm{Complex{T}}</code>: The result of a<em>ℓm * f</em>ℓ.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L397-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.almxfl!" href="#Healpix.almxfl!"><code>Healpix.almxfl!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">almxfl!(alm::Alm{Complex{T}}, fl::AA) where {T &lt;: Number,AA &lt;: AbstractVector{T}}</code></pre><p>Multiply IN-PLACE an a<em>ℓm by a vector b</em>ℓ representing an ℓ-dependent function.</p><p><strong>Arguments</strong></p><ul><li><code>alms::Alm{Complex{T}}</code>: The <code>Alm</code> object containing the spherical harmonics coefficients</li><li><code>fl::AbstractVector{T}</code>: The array containing the factors f<em>ℓ to be multiplied by a</em>ℓm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L369-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+" href="#Base.:+"><code>Base.:+</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">+(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T &lt;: Number}</code></pre><p>Perform the element-wise sum in a_ℓm space. A new <code>Alm</code> object is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L420-L425">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:-" href="#Base.:-"><code>Base.:-</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">-(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T &lt;: Number}</code></pre><p>Perform the element-wise subtraction in a_ℓm space. A new <code>Alm</code> object is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L439-L444">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*" href="#Base.:*"><code>Base.:*</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">*(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T &lt;: Number}</code></pre><p>Perform the element-wise product in a_ℓm space. A new <code>Alm</code> object is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L458-L463">source</a></section><section><div><pre><code class="language-julia hljs">*(alm₁::Alm{Complex{T}}, fl::AA) where {T &lt;: Number, AA &lt;: AbstractVector{T}}</code></pre><p>Perform the product of an <code>Alm</code> object by a function of ℓ in a_ℓm space. Note: this consists in a shortcut of <a href="#Healpix.almxfl"><code>almxfl</code></a>, therefore a new <code>Alm</code> object is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L483-L489">source</a></section><section><div><pre><code class="language-julia hljs">*(alm₁::Alm{Complex{T}}, fl::AbstractVector{T}) where {T &lt;: Number}</code></pre><p>Perform the element-wise product of an <code>Alm</code> object by a constant in a_ℓm space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L492-L496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:/" href="#Base.:/"><code>Base.:/</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">/(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T &lt;: Number}</code></pre><p>Perform an element-wise division in a_ℓm space between two <code>Alm</code>s. A new <code>Alm</code> object is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L506-L511">source</a></section><section><div><pre><code class="language-julia hljs">/(alm₁::Alm{Complex{T}}, fl::AA) where {T &lt;: Number,AA &lt;: AbstractVector{T}}</code></pre><p>Perform an element-wise division by a function of ℓ in a_ℓm space. A new <code>Alm</code> object is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L531-L536">source</a></section><section><div><pre><code class="language-julia hljs">/(alm₁::Alm{Complex{T}}, c::Number) where {T &lt;: Number}</code></pre><p>Perform an element-wise division by a constant in a_ℓm space. A new <code>Alm</code> object is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L539-L544">source</a></section></article><h4 id="Dot-product"><a class="docs-heading-anchor" href="#Dot-product">Dot product</a><a id="Dot-product-1"></a><a class="docs-heading-anchor-permalink" href="#Dot-product" title="Permalink"></a></h4><p>Healpix.jl implements an overload of the operator <code>LinearAlgebra.dot</code> (along with its shortcut <code>⋅</code>) to perform a dot product directly in harmonic space.</p><pre><code class="language-julia hljs">using Healpix
myalm = Healpix.Alm(5,5, ones(ComplexF64, Healpix.numberOfAlms(5)))

dot_res = myalm ⋅ myalm #equivalent to dot(myalm, myalm)</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot" href="#LinearAlgebra.dot"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.dot(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T &lt;: Number}</code></pre><p>Implements the dot product in a_ℓm space. The two imput alms must have matching size, lmax and mmax. A new <code>Alm</code> object is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L555-L561">source</a></section></article><h2 id="Loading-and-saving-harmonic-coefficients"><a class="docs-heading-anchor" href="#Loading-and-saving-harmonic-coefficients">Loading and saving harmonic coefficients</a><a id="Loading-and-saving-harmonic-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-and-saving-harmonic-coefficients" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.readAlmFromFITS" href="#Healpix.readAlmFromFITS"><code>Healpix.readAlmFromFITS</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readAlmFromFITS{T &lt;: Complex}(f::CFITSIO.FITSFile, t::Type{T}) -&gt; Alm{T}
readAlmFromFITS{T &lt;: Complex}(fileName::String, t::Type{T}) -&gt; Alm{T}</code></pre><p>Read a set of a_ℓm coefficients from a FITS file. If the code fails, CFITSIO will raise an exception. (Refer to the CFITSIO library for more information.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L76-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.writeAlmToFITS" href="#Healpix.writeAlmToFITS"><code>Healpix.writeAlmToFITS</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writeAlmToFITS(f::CFITSIO.FITSFile, alm::Alm{Complex{T}}) where {T &lt;: Number}
writeAlmToFITS(fileName, alm::Alm{Complex{T}}; overwrite = true) where {T &lt;: Number}</code></pre><p>Write a set of a_ℓm coefficients into a FITS file. If the code fails, CFITSIO will raise an exception. (Refer to the CFITSIO library for more information.) In the fits file the alms are written with explicit index scheme, <span>$\mathrm{index} = ℓ^2 + ℓ + m + 1$</span>, possibly out of order (check <code>almExplicitIndex</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L257-L266">source</a></section></article><h2 id="Alm-Indexing"><a class="docs-heading-anchor" href="#Alm-Indexing">Alm Indexing</a><a id="Alm-Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Alm-Indexing" title="Permalink"></a></h2><p>You can use <a href="#Healpix.almExplicitIndex"><code>almExplicitIndex</code></a> to compute the so-called explicit indexing. It is exploited for instance in <a href="#Healpix.readAlmFromFITS"><code>readAlmFromFITS</code></a> and <a href="#Healpix.writeAlmToFITS"><code>writeAlmToFITS</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.almExplicitIndex" href="#Healpix.almExplicitIndex"><code>Healpix.almExplicitIndex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">almExplicitIndex(lmax) -&gt; Vector{Int}
almExplicitIndex(lmax, mmax) -&gt; Vector{Int}
almExplicitIndex(alm::Alm{T}) where {T} -&gt; Vector{Int}</code></pre><p>Compute the explicit index scheme, i.e. <span>$\mathrm{index} = ℓ^2 + ℓ + m + 1$</span> up to a certain <span>$ℓ$</span> and <span>$m$</span> if specified, or taken from the <code>Alm</code> passed. If not passed, <code>mmax</code> is defaulted to <code>lmax</code>. If <code>lmax</code> and <code>mmax</code> are inconsistent or negative, a <code>DomainError</code> exception is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L120-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eachindex" href="#Base.eachindex"><code>Base.eachindex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachindex(alm::Alm{Complex{T}}) where {T &lt;: Number}</code></pre><p>Works as <code>eachindex(alm.alm)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L249-L253">source</a></section></article><p>The following functions can be used, in an analogous way as <a href="#Base.eachindex"><code>eachindex</code></a>, in the case of arrays, to obtain sets of indexes or values of <span>$\ell$</span> and <span>$m$</span>.</p><p>On the same line as <code>eachindex</code>, these can be very useful when implementing for-cycles over <code>Alm</code> objects. Here is an example of how to exploit <a href="#Healpix.each_ell_m"><code>each_ell_m</code></a> to print explicitly the major-m ordering of a set of complex-stored <code>Alm</code>:</p><pre><code class="language-julia hljs">using Random

# Initialize a random set of alm
alm = Alm(4,4, randn(ComplexF64, numberOfAlms(4,4)))

#print a_lm values knowing each corresponding l and m values
function print_alm(alm)
    i=1
    for (l,m) in each_ell_m(alm)
        a_lm = alm.alm[i]
        print(&quot;ℓ = $l, |m| = $m: a_ℓm = $a_lm \n&quot;)
        i+=1
    end
end

print_alm(alm)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ℓ = 0, |m| = 0: a_ℓm = 0.674166420426957 + 0.12015940852663665im
ℓ = 1, |m| = 0: a_ℓm = 0.26995659480246836 - 0.8844655146931267im
ℓ = 2, |m| = 0: a_ℓm = -0.04981357923916372 + 1.4300721142872432im
ℓ = 3, |m| = 0: a_ℓm = -0.18587542663747117 - 0.8335273998823308im
ℓ = 4, |m| = 0: a_ℓm = -0.09984967044067523 + 0.07514927027045089im
ℓ = 1, |m| = 1: a_ℓm = 1.152496792202116 - 0.17820745395383283im
ℓ = 2, |m| = 1: a_ℓm = -0.6196955065952905 + 0.110454124464739im
ℓ = 3, |m| = 1: a_ℓm = -0.41081488076034667 - 0.17405438966620063im
ℓ = 4, |m| = 1: a_ℓm = 0.1274235417609124 + 0.0007035695547599746im
ℓ = 2, |m| = 2: a_ℓm = 0.4574996495040741 + 0.7724404207390505im
ℓ = 3, |m| = 2: a_ℓm = -0.6792132205217944 + 1.0835084382488063im
ℓ = 4, |m| = 2: a_ℓm = -0.7480159232895027 + 0.38608227767646486im
ℓ = 3, |m| = 3: a_ℓm = -0.8786830655943982 - 1.3432904461294208im
ℓ = 4, |m| = 3: a_ℓm = -0.13105413821878326 - 0.0836995560865279im
ℓ = 4, |m| = 4: a_ℓm = -0.15012829847205797 - 0.6991209480376886im</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.each_ell" href="#Healpix.each_ell"><code>Healpix.each_ell</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">each_ell(alm::Alm{Complex{T}}, m::Integer) where {T &lt;: Number} -&gt; Vector{Int}
each_ell(alm::Alm{Complex{T}}, ms::AbstractVector{I}) where {T &lt;: Number, I &lt;: Integer} -&gt; Vector{Int}</code></pre><p>Returns an array of all the allowed ℓ values in <code>alm</code> for the given <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.each_ell_idx" href="#Healpix.each_ell_idx"><code>Healpix.each_ell_idx</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">each_ell_idx(alm::Alm{Complex{T}}, m::Integer) where {T &lt;: Number} -&gt; Vector{Int}
each_ell_idx(alm::Alm{Complex{T}}, ms::AbstractVector{I}) where {T &lt;: Number, I &lt;: Integer} -&gt; Vector{Int}</code></pre><p>Returns an array of the indexes of the harmonic coefficients in <code>alm</code> corresponding to all the ℓ values for the given m value(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.each_m" href="#Healpix.each_m"><code>Healpix.each_m</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">each_m(alm::Alm{Complex{T}}, l::Integer) where {T &lt;: Number} -&gt; Vector{Int}
each_m(alm::Alm{Complex{T}}, ls::AbstractVector{I}) where {T &lt;: Number, I &lt;: Integer} -&gt; Vector{Int}</code></pre><p>Returns an array containing all the allowed m values in <code>alm</code> for the given ℓ value(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.each_m_idx" href="#Healpix.each_m_idx"><code>Healpix.each_m_idx</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">each_m_idx(alm::Alm{Complex{T}}, l::Integer) where {T &lt;: Number} -&gt; Vector{Int}
each_m_idx(alm::Alm{Complex{T}}, ls::AbstractVector{I}) where {T &lt;: Number, I &lt;: Integer} -&gt; Vector{Int}</code></pre><p>Returns an array of the indexes of the harmonic coefficients in <code>alm</code> corresponding to all the allowed m values for the given ℓ value(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L213-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.each_ell_m" href="#Healpix.each_ell_m"><code>Healpix.each_ell_m</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">each_ell_m(alm::Alm{Complex{T}}) where {T &lt;: Number} -&gt; Vector{Int}</code></pre><p>Returns an array of tuples <code>(l, m)</code> of all the ℓ and m values of <code>alm</code> in m-major order (the same order as how the harmonic coefficients are stored in <code>Alm</code> objects).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/alm.jl#L229-L234">source</a></section></article><h2 id="Full-Pixel-Weights"><a class="docs-heading-anchor" href="#Full-Pixel-Weights">Full Pixel Weights</a><a id="Full-Pixel-Weights-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Pixel-Weights" title="Permalink"></a></h2><p>The default <a href="#Healpix.map2alm"><code>map2alm</code></a> uses iteration to obtain an accurate transform. One can instead apply a pixel weight to compute an accurate transform in a single pass, like quadrature. The easiest way to the pixel weight files is to run</p><pre><code class="language-sh hljs">git clone --depth 1 https://github.com/healpy/healpy-data</code></pre><p>These weights are in a compressed format that is read with <a href="#Healpix.readFullWeights"><code>readFullWeights</code></a> and multiplied into a map with <a href="#Healpix.applyFullWeights!"><code>applyFullWeights!</code></a>.</p><pre><code class="language-julia hljs">nside = 32
compressed_weights = Healpix.readFullWeights(
    &quot;healpix_full_weights_nside_$(lpad(nside,4,&#39;0&#39;)).fits&quot;)
m = Healpix.HealpixMap{Float64,Healpix.RingOrder}(ones(Healpix.nside2npix(nside)))
Healpix.applyFullWeights!(m, compressed_weights)
alm = Healpix.map2alm(m; niter=0)</code></pre><p>The subsequent <a href="#Healpix.map2alm"><code>map2alm</code></a> only needs <code>niter=0</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.readFullWeights" href="#Healpix.readFullWeights"><code>Healpix.readFullWeights</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readFullWeights(filename::String)</code></pre><p>Read the set of pixel weights used to compute the generalized Fourier transform of a map.</p><p>These weights are usually precomputed; you can download the ones available in the <a href="https://github.com/healpy/healpy-data">Healpy repository</a> using the following command:</p><pre><code class="language-sh hljs">git clone --depth 1 https://github.com/healpy/healpy-data</code></pre><p><strong>Arguments:</strong></p><ul><li><code>filename::String</code>: filename of the full pixel weights</li></ul><p><strong>Returns:</strong></p><ul><li><code>Vector{Float64}</code>: contains the compressed pixel weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/weights.jl#L23-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Healpix.applyFullWeights!" href="#Healpix.applyFullWeights!"><code>Healpix.applyFullWeights!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyFullWeights!(m::HealpixMap{T, RingOrder}, [wgt::Vector{T}]) where T</code></pre><p>Apply a pixel weighting to a map for more accurate SHTs. Note that this only helps for <code>lmax&lt;=1.5*Nside</code>. If this is not the case, the pixel weights may do more harm than good.</p><p>Pixel weights are automatically downloaded if not specified.</p><p><strong>Arguments:</strong></p><ul><li><code>m::HealpixMap{T, RingOrder}</code>: map to modify</li><li><code>wgt::Vector{T}</code> (optional): compressed pixel weights. If not specified, this routine will   look for weights in artifacts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/weights.jl#L50-L63">source</a></section><section><div><pre><code class="language-julia hljs">applyFullWeights!(m::PolarizedHealpixMap{T, RingOrder}, [wgt::Vector{T}]) where T</code></pre><p>Apply a pixel weighting to a polarized map for more accurate SHTs.</p><p><strong>Arguments:</strong></p><ul><li><code>m::PolarizedHealpixMap{T, RingOrder}</code>: map to modify</li><li><code>wgt::Vector{T}</code> (optional): compressed pixel weights. If not specified, an artifact        will be sought.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ziotom78/Healpix.jl/blob/b1316df23ae8183a6f52d68fe9a3c5fa4f736194/src/weights.jl#L108-L117">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mapfunc/">« Map functions</a><a class="docs-footer-nextpage" href="../Cl/">Power Spectrum »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Wednesday 4 June 2025 09:16">Wednesday 4 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
