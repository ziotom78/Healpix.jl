var documenterSearchIndex = {"docs":
[{"location":"query/","page":"Query functions","title":"Query functions","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"query/#Query-functions","page":"Query functions","title":"Query functions","text":"","category":"section"},{"location":"query/","page":"Query functions","title":"Query functions","text":"It is often useful to perform calculations on a set of adjacent pixels in a map. Asking for the indices of pixels within a given region of the sphere is called a query, and this kind of function can be implemented efficiently using the Healpix scheme.","category":"page"},{"location":"query/","page":"Query functions","title":"Query functions","text":"The functions that query a set of pixels satisfying some proximity criteria are the following:","category":"page"},{"location":"query/","page":"Query functions","title":"Query functions","text":"queryDiscRing\nqueryStripRing","category":"page"},{"location":"query/","page":"Query functions","title":"Query functions","text":"Let's show an example about how to use queryDiscRing, which returns a list of the indexes of the pixels that fall within some angle from a direction on the sky sphere:","category":"page"},{"location":"query/","page":"Query functions","title":"Query functions","text":"using Healpix # hide\nresol = Resolution(32)\n(theta, phi) = (1.3, 0.7)\nradius = deg2rad(10.0)\npixidx = queryDiscRing(resol, theta, phi, radius)","category":"page"},{"location":"query/","page":"Query functions","title":"Query functions","text":"We can visualize where these pixels are using a Mollweide projection:","category":"page"},{"location":"query/","page":"Query functions","title":"Query functions","text":"m = HealpixMap{Float32, RingOrder}(resol.nside);\nm[pixidx] .= 1;\n\nm[ang2pix(m, theta, phi)] = 2  # Highlight the pixel at the center\n\nusing Plots\npyplot()  # hide\nplot(m)\nsavefig(joinpath(\"images\", \"querydisc.png\")) # hide","category":"page"},{"location":"query/","page":"Query functions","title":"Query functions","text":"(Image: )","category":"page"},{"location":"query/","page":"Query functions","title":"Query functions","text":"The function queryDiscRing accepts an optional keyword fact that specifies the resolution to be used in computing the result; it can be any positive integer, and the actual resolution is fact * NSIDE.","category":"page"},{"location":"query/#Reference","page":"Query functions","title":"Reference","text":"","category":"section"},{"location":"query/","page":"Query functions","title":"Query functions","text":"queryDiscRing\nqueryStripRing","category":"page"},{"location":"query/#Healpix.queryDiscRing","page":"Query functions","title":"Healpix.queryDiscRing","text":"queryDiscRing(resol::Resolution, theta, phi, radius; fact=0)\n\nReturn a list of the indices of those pixels whose centers are closer than radius to direction (theta, phi). The three angles radius, theta, and phi must be expressed in radians.\n\nIf fact is nonzero, it must be a positive integer; it requires to carry the computation at a resolution fact * nside.\n\n\n\n\n\n","category":"function"},{"location":"query/#Healpix.queryStripRing","page":"Query functions","title":"Healpix.queryStripRing","text":"queryStripRing(resol::Resolution, theta1, theta2; inclusive=true)\n\nReturn a range of the indices of pixels that overlap with the colatitude range [theta1, theta2]. If inclusive is set to false, only those pixels whose centers lie within the colatitude range are returned.\n\nThis function assumes the RING scheme, because in this case, the indexes of the pixels cover a range without gaps. Therefore, the function returns a range instead of a list, as it is quicker and occupies far less memory.\n\n\n\n\n\n","category":"function"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"alm/#Spherical-harmonics","page":"Spherical harmonics","title":"Spherical harmonics","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Starting from version 2.4, Healpix.jl implements generalized Fourier transformations through the libsharp library, to convert a map from its pixel-space representation to its decomposition in spherical harmonics. This has multiple applications, the most relevant being the analysis of Cosmic Microwave Background maps and the efficient computation of convolution operators.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Everything revolves around the Alm type, which encodes a set of spherical harmonics and is thus conceptually equivalent to the concept of a HealpixMap, only living in the harmonic space:","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Alm","category":"page"},{"location":"alm/#Healpix.Alm","page":"Spherical harmonics","title":"Healpix.Alm","text":"An array of harmonic coefficients (a_ℓm).\n\nThe type T is used for the value of each harmonic coefficient, and it must be a Number (one should however only use complex types for this). The type AA is used to store the array of coefficients; a typical choice is Vector.\n\nA Alm type contains the following fields:\n\nalm: the array of harmonic coefficients\nlmax: the maximum value for ℓ\nmmax: the maximum value for m\ntval: maximum number of m coefficients for the maximum ℓ\n\nThe a_ell m are stored by m: if ell_max is 16, the first 16 elements are m=0, ell=0-16, then the following 15 elements are m=1, ell=1-16, then m=2, ell=2-16 and so on until the last element, the 153th, is m=16, ell=16.\n\n\n\n\n\n","category":"type"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"In the general case, the number of coefficients in a spherical harmonic expansion is infinite. For obvious reasons, Healpix.jl only allows to store band-limited expansions. The function numberOfAlms returns the number of floating-point numbers used to store the expansion, as a function of the maximum value for ell and m.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"numberOfAlms","category":"page"},{"location":"alm/#Healpix.numberOfAlms","page":"Spherical harmonics","title":"Healpix.numberOfAlms","text":"numberOfAlms(lmax::Integer, mmax::Integer) -> Integer\nnumberOfAlms(lmax::Integer) -> Integer\n\nReturn the size of the array of complex numbers needed to store the a_ℓm coefficients in the range of ℓ and m specified by lmax and mmax. If mmax is not specified, it is assumed to be equal to lmax. If lmax and mmax are inconsistent or negative, a DomainError exception is thrown.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Converting-between-pixel-space-and-harmonic-space","page":"Spherical harmonics","title":"Converting between pixel space and harmonic space","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Healpix.jl implements the four functions alm2map, map2alm, alm2map!, and map2alm! to convert a map from a pixel-space representation to the harmonic space and vice-versa. The functions ending with ! are mutating functions, which means that they assume that the result must be saved in a preallocated variable; they are space- and time-efficient and should be used when you want your code to be performant, or when you plan to apply the same operation several times (e.g., in a Monte Carlo simulation). The synthesis operation (alm2map) is generally referred to with the matrix operator mathrmY, while his inverse (map2alm) with mathrmY^-1.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Healpix.jl also implements the two adjoint functions adjoint_alm2map! and adjoint_map2alm!, represented by mathrmY^mathrmT and (mathrmY^-1)^mathrmT respectively. While the synthesis operator on a general scalar field f(theta phi) can be defined through an exact summation as f(theta phi) = mathrmY  a_ell m quad textwhere quad f(theta phi) = sum_ell=0^infty sum_m=-ell^ell a_ell m Y_ell m (theta phi). The analysis operator is defined through an integral operator as a_ell m = mathrmY^-1 f(theta phi) quad textwhere quad a_ell m = int_0^2pi int_0^pi Y^*_ell m(theta phi) f(theta phi) sintheta  dtheta dphi. Though, in the real case wherein maps are pixelized, the latter ends up being approximated through a summation over the pixels. Here is where the adjoint of the synthesis operator, mathrmY^mathrmT, comes into play. It is defined through: $ \\mathrm{Y}^{\\mathrm{T}} f(\\theta, \\phi) \\equiv \\sum{i = 1}^{N{\\mathrm{pix}}} Y^*{\\ell m,\\, i} \\, fi,$ which is an exact operation. Note that the latter does not give directly the a_ell m coefficients, since mathrmY^-1 simeq mathrmW mathrmY^mathrmT, where mathrmW is a diagonal matrix whose non-zero elements are approximately constant and equal to 4 pi  N_mathrmpix, depending on the map pixelization. The latter realtion is also useful to obtain the adjoint of the analysis operator: (mathrmY^-1)^mathrmT = mathrmW^mathrmTmathrmY =  mathrmWmathrmY.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Here is an example:","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"using Healpix # hide\nusing Random\n\n# Ensure reproducibility by using a fixed seed\nRandom.seed!(1234)\n\nnside = 8\nm = HealpixMap{Float32,RingOrder}(nside)\n\n# Initialize the pixels to random values in the 0…1 range\nfor i in 1:length(m)\n    m[i] = rand(Float32)\nend\n\nalm = map2alm(m)\n\n# Go back to pixel space\nnewm = alm2map(alm, nside)","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"The variable newm is a map that is close enough to m, yet it is not exactly the same because of the approximations done by both map2alm and alm2map.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"map2alm!\nmap2alm\nalm2map!\nalm2map\nadjoint_alm2map!\nadjoint_map2alm!","category":"page"},{"location":"alm/#Healpix.map2alm!","page":"Spherical harmonics","title":"Healpix.map2alm!","text":"map2alm!(map::HealpixMap{Float64, RingOrder, Array{Float64, 1}}, alm::Alm{ComplexF64, Array{ComplexF64, 1}}; niter::Integer=3)\nmap2alm!(map::PolarizedHealpixMap{Float64, RingOrder, Array{Float64, 1}}, alm::Array{Alm{ComplexF64, Array{ComplexF64, 1}},1};\n    niter::Integer=3)\n\nThis function performs a spherical harmonic transform on the map and places the results in the passed alm object. This function requires types derived from Float64, since it is done in-place.\n\nArguments\n\nmap: the map that must be decomposed in spherical harmonics. It can either be a HealpixMap{Float64, RingOrder} type (scalar map) or a PolarizedHealpixMap{Float64, RingOrder} type (polarized map).\nalm::Alm{ComplexF64, Array{ComplexF64, 1}}: the spherical harmonic coefficients to be written to.\n\nKeywords\n\nniter::Integer: number of iterations of SHTs to perform, to enhance accuracy\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.map2alm","page":"Spherical harmonics","title":"Healpix.map2alm","text":"map2alm(map::HealpixMap{Float64, RingOrder, AA};\n    lmax=nothing, mmax=nothing, niter::Integer=3)\nmap2alm(m::HealpixMap{T, RingOrder, AA}; lmax=nothing, mmax=nothing,\n    niter::Integer=3) where {T <: Real, AA <: AbstractArray{T, 1} }\n\nCompute the spherical harmonic coefficients of a map. To enhance precision, more iterations of the transforms can be performed by passing a nonzero niter. The underlying SHT library libsharp performs all calculations using Cdouble types, so all inputs are converted to types based on Float64.\n\nArguments\n\nmap: the map to decompose in spherical harmonics. It can either be a HealpixMap{T, RingOrder, AA} type (scalar map) or a PolarizedHealpixMap{T, RingOrder, AA} type (polarized map).\n\nKeywords\n\nlmax::Integer: the maximum ℓ coefficient, will default to 3*nside-1 if not specified.\nmmax::Integer: the maximum m coefficient\nniter::Integer: number of SHT iterations, to enhance precision. Defaults to 3\n\nReturns\n\nAlm{ComplexF64, Array{ComplexF64, 1}}: the spherical harmonic coefficients corresponding to the map\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.alm2map!","page":"Spherical harmonics","title":"Healpix.alm2map!","text":"alm2map!(alm::Alm{ComplexF64, Array{ComplexF64, 1}}, map::HealpixMap{Float64, RingOrder, Array{Float64, 1}})\nalm2map!(alm::Array{Alm{ComplexF64, Array{ComplexF64, 1}},1}, map::PolarizedHealpixMap{Float64, RingOrder, Array{Float64, 1}})\n\nThis function performs a spherical harmonic transform on the map and places the results in the passed alm object. This function requires types derived from Float64, since it is done in-place.\n\nArguments\n\nalm::Alm{ComplexF64, Array{ComplexF64, 1}}: the spherical harmonic coefficients to perform the spherical harmonic transform on.\nmap: the map that will contain the result. It can either be a HealpixMap{Float64, RingOrder, Array{Float64, 1}} type (scalar map) or a PolarizedHealpixMap{Float64, RingOrder, Array{Float64, 1}} (polarized map).\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.alm2map","page":"Spherical harmonics","title":"Healpix.alm2map","text":"alm2map(alm::Alm{ComplexF64, Array{Float64, 1}}, nside::Integer)\nalm2map(alm::Alm{T, Array{T, 1}}, nside::Integer) where T\nalm2map(alm::Array{Alm{ComplexF64, Array{ComplexF64, 1}},1}, nside::Integer)\nalm2map(alms::Array{Alm{T, Array{T, 1}},1}, nside::Integer) where T\n\nCompute a map from spherical harmonic coefficients. The underlying SHT library libsharp performs all calculations in Cdouble, so all inputs are converted to types based on Float64.\n\nArguments\n\nalm: the spherical harmonic coefficients to transform. If of type Alm{T, Array{T, 1}}, we assume a spin-0 spherical harmonic transform. If an array of Alm is passed, we assume that the components correspond to T, E, and B coefficients.\n\nKeywords\n\nnside::Integer: Healpix resolution parameter\n\nReturns\n\nHealpixMap{Float64, RingOrder, Array{Float64, 1}} or PolarizedHealpixMap{Float64, RingOrder, Array{Float64, 1}} depending on if the input alm is of type Alm{T, Array{T, 1}} or Array{Alm{T, Array{T, 1}}} respectively.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.adjoint_alm2map!","page":"Spherical harmonics","title":"Healpix.adjoint_alm2map!","text":"adjoint_alm2map!(map::HealpixMap{Float64, RingOrder, Array{Float64, 1}}, alm::Alm{ComplexF64, Array{ComplexF64, 1}})\nadjoint_alm2map!(map::PolarizedHealpixMap{Float64, RingOrder, Array{Float64, 1}}, alm::Array{Alm{ComplexF64, Array{ComplexF64, 1}},1})\n\nThis function performs a spherical harmonic transform Yᵀ on the map and places the results in the passed alm object. This function requires types derived from Float64, since it is done in-place.\n\nArguments\n\nmap: the map that must be decomposed in spherical harmonics. It can either be a HealpixMap{Float64, RingOrder} type (scalar map) or a PolarizedHealpixMap{Float64, RingOrder} type (polarized map).\nalm::Alm{ComplexF64, Array{ComplexF64, 1}}: the spherical harmonic coefficients to be written to.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.adjoint_map2alm!","page":"Spherical harmonics","title":"Healpix.adjoint_map2alm!","text":"adjoint_map2alm!(alm::Alm{ComplexF64, Array{ComplexF64, 1}}, map::HealpixMap{Float64, RingOrder, Array{Float64, 1}})\nadjoint_map2alm!(alm::Array{Alm{ComplexF64, Array{ComplexF64, 1}},1}, map::PolarizedHealpixMap{Float64, RingOrder, Array{Float64, 1}})\n\nThis function performs the spherical harmonic transform (Y^-1)^t = W^t Y = W Y on the map and places the results in the passed alm object. This function requires types derived from Float64, since it is done in-place.\n\nArguments\n\nalm::Alm{ComplexF64, Array{ComplexF64, 1}}: the spherical harmonic coefficients to perform the spherical harmonic transform on.\nmap: the map that will contain the result. It can either be a HealpixMap{Float64, RingOrder, Array{Float64, 1}} type (scalar map) or a PolarizedHealpixMap{Float64, RingOrder, Array{Float64, 1}} (polarized map).\n\n\n\n\n\n","category":"function"},{"location":"alm/#From-harmonic-coefficients-to-the-power-spectrum","page":"Spherical harmonics","title":"From harmonic coefficients to the power spectrum","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"You can use the function alm2cl to convert a set of a_ell m coefficients into the components C_ell of the power spectrum. The pixelization also induces a transfer function, which can be obtained from pixwin. A simple Gaussian beam window function in the asymptotic small-beam limit can be computed with gaussbeam.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"alm2cl\npixwin\ngaussbeam","category":"page"},{"location":"alm/#Healpix.alm2cl","page":"Spherical harmonics","title":"Healpix.alm2cl","text":"alm2cl(alm::Alm{Complex{T}}) where {T <: Number} -> Vector{T}\nalm2cl(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T <: Number} -> Vector{T}\n\nCompute C_ell from the spherical harmonic coefficients of one or two fields.\n\nArguments\n\nalm₁::Alm{Complex{T}}: the spherical harmonic coefficients of the first field\nalm₂::Alm{Complex{T}}: the spherical harmonic coefficients of the second field\n\nReturns\n\nArray{T} containing C_ell, with the first element referring to ℓ=0.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.pixwin","page":"Spherical harmonics","title":"Healpix.pixwin","text":"pixwin(nside; pol=false)\n\nArguments:\n\nnside: HEALPix resolution parameter\n\nKeywords\n\npol::Bool=false: if true, also return polarization pixel window\n\nReturns:\n\nVector{Float64} pixel window function. If pol=true, returns a Tuple   of the temperature and polarization pixel windows.\n\nExamples\n\njulia> pixwin(4)\n17-element Vector{Float64}:\n 1.0000000000020606\n 0.9942340766588788\n ⋮\n 0.4222841034207188\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.gaussbeam","page":"Spherical harmonics","title":"Healpix.gaussbeam","text":"gaussbeam(fwhm::T, lmax::Int; pol=false) where T\n\nCompute the Gaussian beam window function B_ell given the FWHM of the beam in radians, where C_ell mathrmmeasured = B_ell^2 C_ell. This beam is valid in the limit of sigma^2 ll 0, which is the case for all high-resolution CMB experiments.\n\nArguments\n\nfwhm::T: FWHM of the Gaussian beam in radians\nlmax::Int: maximum multipole ℓ\npol=false: if false, returns the spin-0 beam for i.e. intensity. if true, returns the spin-2 beam\n\nReturns\n\nArray{T,1} containing B_ell, with the first element referring to ℓ=0.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Algebraic-operations-in-harmonic-space","page":"Spherical harmonics","title":"Algebraic operations in harmonic space","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Healpix.jl provides overloads of the Base functions +, -, *, /, as well as LinearAlgebra.dot, allowing to carry out these fundamental operations element-wise in harmonic space directly.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"For example, an element-wise sum between two Alm objects can be performed as follows:","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"using Healpix\n\n#just two constant Alm objects\nmyalm1 = Healpix.Alm(5,5, ones(ComplexF64, Healpix.numberOfAlms(5)))\nmyalm1 = Healpix.Alm(5,5, ones(ComplexF64, Healpix.numberOfAlms(5)))\n\nalm_sum = myalm1 + myalm2 #each element will be = 2 + 0im","category":"page"},{"location":"alm/#Multiplying-or-dividing-a-set-of-Alm-by-a-generic-function-of-\\ell-or-a-constant","page":"Spherical harmonics","title":"Multiplying or dividing a set of Alm by a generic function of ell or a constant","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"The operators * and / can be used to multiply or divide an Alm by an ell-dependent generic function f_ell (or just a constant, of type Number).","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"In this case a new instance of Alm type will be returned. To perform a more efficient in-place operation refer to almxfl!, as shown in this brief example:","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"using Healpix\n\n#just two constant Alm objects\nmyalm = Healpix.Alm(5,5, ones(ComplexF64, Healpix.numberOfAlms(5)))\nmyf_l = ones(Healpix.numberOfAlms(5)) .* 2\n\n#will return a new object:\nmyalm*myf_l\nmyalm/myf_l\n\n#will overwrite myalm:\nalmxfl!(myalm, myf_l)\nalmxfl!(myalm, 1.0 ./ myf_l) #division","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"In either case the call to such operator consists in a shortcut to the function almxfl.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"almxfl\nalmxfl!\nBase.:+\nBase.:-\nBase.:*\nBase.:/","category":"page"},{"location":"alm/#Healpix.almxfl","page":"Spherical harmonics","title":"Healpix.almxfl","text":"almxfl(alm::Alm{Complex{T}}, fl::AbstractVector{T}) where {T <: Number} -> Alm{T}\n\nMultiply an aℓm by a vector bℓ representing an ℓ-dependent function, without changing the a_ℓm passed in input.\n\nARGUMENTS\n\nalms::Alm{Complex{T}}: The Alm object containing the spherical harmonics coefficients\nfl::AbstractVector{T}: The array containing the factors fℓ to be multiplied by aℓm\n\n#RETURNS\n\nAlm{Complex{T}}: The result of aℓm * fℓ.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.almxfl!","page":"Spherical harmonics","title":"Healpix.almxfl!","text":"almxfl!(alm::Alm{Complex{T}}, fl::AA) where {T <: Number,AA <: AbstractArray{T,1}}\n\nMultiply IN-PLACE an aℓm by a vector bℓ representing an ℓ-dependent function.\n\nARGUMENTS\n\nalms::Alm{Complex{T}}: The Alm object containing the spherical harmonics coefficients\nfl::AbstractVector{T}: The array containing the factors fℓ to be multiplied by aℓm\n\n\n\n\n\n","category":"function"},{"location":"alm/#Base.:+","page":"Spherical harmonics","title":"Base.:+","text":"+(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T <: Number}\n\nPerform the element-wise sum in a_ℓm space.\nA new `Alm` object is returned.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Base.:-","page":"Spherical harmonics","title":"Base.:-","text":"-(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T <: Number}\n\nPerform the element-wise subtraction in a_ℓm space.\nA new `Alm` object is returned.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Base.:*","page":"Spherical harmonics","title":"Base.:*","text":"*(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T <: Number}\n\nPerform the element-wise product in a_ℓm space.\nA new `Alm` object is returned.\n\n\n\n\n\n*(alm₁::Alm{Complex{T}}, fl::AA) where {T <: Number, AA <: AbstractArray{T,1}}\n\nPerform the product of an `Alm` object by a function of ℓ in a_ℓm space.\nNote: this consists in a shortcut of [`almxfl`](@ref),\ntherefore a new `Alm` object is returned.\n\n\n\n\n\n*(alm₁::Alm{Complex{T}}, fl::AbstractVector{T}) where {T <: Number}\n\nPerform the element-wise product of an `Alm` object by a constant in a_ℓm space.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Base.:/","page":"Spherical harmonics","title":"Base.:/","text":"/(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}}) where {T <: Number}\n\nPerform an element-wise division in a_ℓm space between two `Alm`s.\nA new `Alm` object is returned.\n\n\n\n\n\n/(alm₁::Alm{Complex{T}}, fl::AA) where {T <: Number,AA <: AbstractArray{T,1}}\n\nPerform an element-wise division by a function of ℓ in a_ℓm space.\nA new `Alm` object is returned.\n\n\n\n\n\n/(alm₁::Alm{Complex{T}}, c::Number) where {T <: Number}\n\nPerform an element-wise division by a constant in a_ℓm space.\nA new `Alm` object is returned.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Dot-product","page":"Spherical harmonics","title":"Dot product","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"Healpix.jl implements an overload of the operator LinearAlgebra.dot (along with its shortcut ⋅) to perform a dot product directly in harmonic space.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"using Healpix\nmyalm = Healpix.Alm(5,5, ones(ComplexF64, Healpix.numberOfAlms(5)))\n\ndot_res = myalm ⋅ myalm #equivalent to dot(myalm, myalm)","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"LinearAlgebra.dot","category":"page"},{"location":"alm/#Loading-and-saving-harmonic-coefficients","page":"Spherical harmonics","title":"Loading and saving harmonic coefficients","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"readAlmFromFITS\nwriteAlmToFITS","category":"page"},{"location":"alm/#Healpix.readAlmFromFITS","page":"Spherical harmonics","title":"Healpix.readAlmFromFITS","text":"readAlmFromFITS{T <: Complex}(f::CFITSIO.FITSFile, t::Type{T}) -> Alm{T}\nreadAlmFromFITS{T <: Complex}(fileName::String, t::Type{T}) -> Alm{T}\n\nRead a set of a_ℓm coefficients from a FITS file. If the code fails, CFITSIO will raise an exception. (Refer to the CFITSIO library for more information.)\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.writeAlmToFITS","page":"Spherical harmonics","title":"Healpix.writeAlmToFITS","text":"writeAlmToFITS(f::CFITSIO.FITSFile, alm::Alm{Complex{T}}) where {T <: Number}\nwriteAlmToFITS(fileName, alm::Alm{Complex{T}}; overwrite = true) where {T <: Number}\n\nWrite a set of a_ℓm coefficients into a FITS file. If the code fails, CFITSIO will raise an exception. (Refer to the CFITSIO library for more information.) In the fits file the alms are written with explicit index scheme, mathrmindex = ell^2 + ell + m + 1, possibly out of order (check almExplicitIndex).\n\n\n\n\n\n","category":"function"},{"location":"alm/#Alm-Indexing","page":"Spherical harmonics","title":"Alm Indexing","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"You can use almExplicitIndex to compute the so-called explicit indexing. It is exploited for instance in readAlmFromFITS and writeAlmToFITS.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"almExplicitIndex","category":"page"},{"location":"alm/#Healpix.almExplicitIndex","page":"Spherical harmonics","title":"Healpix.almExplicitIndex","text":"almExplicitIndex(lmax) -> Vector{Int}\nalmExplicitIndex(lmax, mmax) -> Vector{Int}\nalmExplicitIndex(alm::Alm{T}) where {T} -> Vector{Int}\n\nCompute the explicit index scheme, i.e. mathrmindex = ell^2 + ell + m + 1 up to a certain ℓ and m if specified, or taken from the Alm passed. If not passed, mmax is defaulted to lmax. If lmax and mmax are inconsistent or negative, a DomainError exception is thrown.\n\n\n\n\n\n","category":"function"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"The following functions can be used, in an analogous way as eachindex, in the case of arrays, to obtain sets of indexes or values of ell and m.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"On the same line as eachindex, these can be very useful when implementing for-cycles over Alm objects. Here is an example of how to exploit each_ell_m to print explicitly the major-m ordering of a set of complex-stored Alm:","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"\nusing Healpix # hide\nusing Random\n\n# Initialize a random set of alm\nalm = Alm(4,4, randn(ComplexF64, numberOfAlms(4,4)))\n\n#print a_lm values knowing each corresponding l and m values\nfunction print_alm(alm)\n    i=1\n    for (l,m) in each_ell_m(alm)\n        a_lm = alm.alm[i]\n        print(\"ℓ = $l, |m| = $m: a_ℓm = $a_lm \\n\")\n        i+=1\n    end\nend\n\nprint_alm(alm)","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"each_ell\neach_ell_idx\neach_m\neach_m_idx\neach_ell_m","category":"page"},{"location":"alm/#Healpix.each_ell","page":"Spherical harmonics","title":"Healpix.each_ell","text":"eachell(alm::Alm{Complex{T}}, m::Integer) where {T <: Number} -> Vector{Int}     eachell(alm::Alm{Complex{T}}, ms::AbstractArray{I, 1}) where {T <: Number, I <: Integer} -> Vector{Int}\n\nReturns an array of all the allowed ℓ values in `alm` for the given `m`.\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.each_ell_idx","page":"Spherical harmonics","title":"Healpix.each_ell_idx","text":"eachellidx(alm::Alm{Complex{T}}, m::Integer) where {T <: Number} -> Vector{Int}     eachellidx(alm::Alm{Complex{T}}, ms::AbstractArray{I, 1}) where {T <: Number, I <: Integer} -> Vector{Int}\n\nReturns an array of the indexes of the harmonic coefficients in `alm` corresponding\nto all the ℓ values for the given m value(s).\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.each_m","page":"Spherical harmonics","title":"Healpix.each_m","text":"eachm(alm::Alm{Complex{T}}, l::Integer) where {T <: Number} -> Vector{Int}     eachm(alm::Alm{Complex{T}}, ls::AbstractArray{I, 1}) where {T <: Number, I <: Integer} -> Vector{Int}\n\nReturns an array containing all the allowed m values in `alm` for the given ℓ value(s).\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.each_m_idx","page":"Spherical harmonics","title":"Healpix.each_m_idx","text":"eachmidx(alm::Alm{Complex{T}}, l::Integer) where {T <: Number} -> Vector{Int}     eachmidx(alm::Alm{Complex{T}}, ls::AbstractArray{I, 1}) where {T <: Number, I <: Integer} -> Vector{Int}\n\nReturns an array of the indexes of the harmonic coefficients in `alm` corresponding\nto all the allowed m values for the given ℓ value(s).\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.each_ell_m","page":"Spherical harmonics","title":"Healpix.each_ell_m","text":"eachellm(alm::Alm{Complex{T}}) where {T <: Number} -> Vector{Int}\n\nReturns an array of tuples `(l, m)` of all the ℓ and m values of `alm` in\nm-major order (the same order as how the harmonic coefficients are stored in `Alm` objects).\n\n\n\n\n\n","category":"function"},{"location":"alm/#Full-Pixel-Weights","page":"Spherical harmonics","title":"Full Pixel Weights","text":"","category":"section"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"The default map2alm uses iteration to obtain an accurate transform. One can instead apply a pixel weight to compute an accurate transform in a single pass, like quadrature. The easiest way to the pixel weight files is to run","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"git clone --depth 1 https://github.com/healpy/healpy-data","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"These weights are in a compressed format that is read with readFullWeights and multiplied into a map with applyFullWeights!.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"nside = 32\ncompressed_weights = Healpix.readFullWeights(\n    \"healpix_full_weights_nside_$(lpad(nside,4,'0')).fits\")\nm = Healpix.HealpixMap{Float64,Healpix.RingOrder}(ones(Healpix.nside2npix(nside)))\nHealpix.applyFullWeights!(m, compressed_weights)\nalm = Healpix.map2alm(m; niter=0)","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"The subsequent map2alm only needs niter=0.","category":"page"},{"location":"alm/","page":"Spherical harmonics","title":"Spherical harmonics","text":"readFullWeights\napplyFullWeights!","category":"page"},{"location":"alm/#Healpix.readFullWeights","page":"Spherical harmonics","title":"Healpix.readFullWeights","text":"readFullWeights(filename::String)\n\nRead the set of pixel weights used to compute the generalized Fourier transform of a map.\n\nThese weights are usually precomputed; you can download the ones available in the Healpy repository using the following command:\n\ngit clone --depth 1 https://github.com/healpy/healpy-data\n\nArguments:\n\nfilename::String: filename of the full pixel weights\n\nReturns:\n\nVector{Float64}: contains the compressed pixel weights\n\n\n\n\n\n","category":"function"},{"location":"alm/#Healpix.applyFullWeights!","page":"Spherical harmonics","title":"Healpix.applyFullWeights!","text":"applyFullWeights!(m::HealpixMap{T, RingOrder}, [wgt::Vector{T}]) where T\n\nApply a pixel weighting to a map for more accurate SHTs. Note that  this only helps for lmax<=1.5*Nside. If this is not the case, the  pixel weights may do more harm than good.\n\nPixel weights are automatically downloaded if not specified. \n\nArguments:\n\nm::HealpixMap{T, RingOrder}: map to modify\nwgt::Vector{T} (optional): compressed pixel weights. If not specified, this routine will   look for weights in artifacts.\n\n\n\n\n\napplyFullWeights!(m::PolarizedHealpixMap{T, RingOrder}, [wgt::Vector{T}]) where T\n\nApply a pixel weighting to a polarized map for more accurate SHTs.\n\nArguments:\n\nm::PolarizedHealpixMap{T, RingOrder}: map to modify\nwgt::Vector{T} (optional): compressed pixel weights. If not specified, an artifact        will be sought.\n\n\n\n\n\n","category":"function"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"Cl/#Power-Spectrum","page":"Power Spectrum","title":"Power Spectrum","text":"","category":"section"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"Power spectrum components C_ell are encoded as Vector{T}. Healpix.jl implements functions to perform sht operations on power spectra, e.g. to obtain a map or a set of 'Alm', as well as writing/reading a power spectrum from a FITS file.","category":"page"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"The functions ending with ! are mutating functions, which means that they assume that the result must be saved in a preallocated variable; they are space- and time-efficient and should be used when you want your code to be performant, or when you plan to apply the same operation several times (e.g., in a Monte Carlo simulation).","category":"page"},{"location":"Cl/#Loading-and-saving-power-spectrum-components","page":"Power Spectrum","title":"Loading and saving power spectrum components","text":"","category":"section"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"Healpix.jl implements functions to read/write the components C_ell from/to a FITS files.","category":"page"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"readClFromFITS\nwriteClToFITS","category":"page"},{"location":"Cl/#Healpix.readClFromFITS","page":"Power Spectrum","title":"Healpix.readClFromFITS","text":"readClFromFITS{T <: Real}(f::CFITSIO.FITSFile, t::Type{T}; col_num = 2) -> Vector{T}\nreadClFromFITS{T <: Real}(fileName::String, t::Type{T}; col_num = 2) -> Vector{T}\n\nRead a set of C_ℓ coefficients from a FITS file.\n\n\n\n\n\n","category":"function"},{"location":"Cl/#Healpix.writeClToFITS","page":"Power Spectrum","title":"Healpix.writeClToFITS","text":"writeClToFITS(f::CFITSIO.FITSFile, Cl::Vector{T}) where {T <: Real}\nwriteClToFITS(fileName, Cl::Vector{T}; overwrite = true) where {T <: Real}\n\nWrite a set of C_ℓ coefficients to a FITS file.\n\n\n\n\n\n","category":"function"},{"location":"Cl/#Converting-different-power-spectrum-representation","page":"Power Spectrum","title":"Converting different power spectrum representation","text":"","category":"section"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"It's often useful to represent, especially for plotting it, the power spectrum in the form of D_ell. Healpix.jl implements a couple of functions to convert a power spectrum from/to such a representation.","category":"page"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"cl2dl\ndl2cl","category":"page"},{"location":"Cl/#Healpix.cl2dl","page":"Power Spectrum","title":"Healpix.cl2dl","text":"cl2dl(cl::AbstractVector{T}, lmin::Integer) where {T <: Real}\n\nConvert a set of C_ell to D_ell power spectrum, where D_ell = ell (ell + 1) C_ell  2pi. The first components are set to zero if not present.\n\nArguments:\n\ncl::AbstractVector{T} : Array of C_ℓ components\nlmin::Integer : minimum l in the representation of the C_ℓ power spectrum\n\nReturns:\n\nVector{T} : Array of D_ℓ power spectrum components\n\n\n\n\n\n","category":"function"},{"location":"Cl/#Healpix.dl2cl","page":"Power Spectrum","title":"Healpix.dl2cl","text":"dl2cl(dl::AbstractVector{T}, lmin::Integer) where {T <: Real}\n\nConvert a set of D_ell to C_ell power spectrum, where C_ell = 2pi D_ell  ell (ell + 1). The first components are set to zero if not present. The monopole component is set to zero in any case to avoid Inf values.\n\nArguments:\n\ndl::AbstractVector{T} : Array of D_ℓ components\nlmin::Integer : minimum l in the representation of the Dℓ power spectrum\n\nReturns:\n\nVector{T} : Array of C_ℓ power spectrum components\n\n\n\n\n\n","category":"function"},{"location":"Cl/#Synthesizing-harmonic-coefficients-from-power-spectrum","page":"Power Spectrum","title":"Synthesizing harmonic coefficients from power spectrum","text":"","category":"section"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"Generate a Alm instance with a random set of a_ell m coefficients. Each harmonic coefficient a_ell m is a realization of a gaussian distribution with zero mean and C_ell variance.","category":"page"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"synalm!\nsynalm","category":"page"},{"location":"Cl/#Healpix.synalm!","page":"Power Spectrum","title":"Healpix.synalm!","text":"synalm!(cl::Vector{T}, alm::Alm{ComplexF64, Vector{ComplexF64}}, rng::AbstractRNG) where {T <: Real}\nsynalm!(cl::Vector{T}, alm::Alm{ComplexF64, Vector{ComplexF64}}) where {T <: Real}\n\nGenerate a set of a_ell m from a given power spectra C_ell. The output is written into the Alm object passed in input.\n\nArguments:\n\ncl::AbstractVector{T}: The array representing the power spectrum components C_ell,\n\nstarting from ell = 0.\n\nalm::Alm{Complex{T}}: The array representing the spherical harmonics coefficients a_ell m\n\nwe want to write the result into.\n\nrng::AbstractRNG : (optional) the RNG to be used for generating the a_ell m. It allows\n\nto set the seed beforehand guaranteeing the reproducibility of the process.\n\n\n\n\n\n","category":"function"},{"location":"Cl/#Healpix.synalm","page":"Power Spectrum","title":"Healpix.synalm","text":"synalm(cl::Vector{T}, lmax::Integer, mmax::Integer, rng::AbstractRNG) where {T <: Real}\nsynalm(cl::Vector{T}, lmax::Integer, mmax::Integer) where {T <: Real}\nsynalm(cl::Vector{T}, lmax::Integer, rng::AbstractRNG) where {T <: Real}\nsynalm(cl::Vector{T}, lmax::Integer) where {T <: Real}\nsynalm(cl::Vector{T}, rng::AbstractRNG) where {T <: Real}\nsynalm(cl::Vector{T}) where {T <: Real}\n\nGenerate a set of a_ell m from a given power spectra C_ell. The output is written into a new Alm object of given lmax.\n\nArguments:\n\ncl::AbstractVector{T}: The array representing the power spectrum components C_ell,\n\nstarting from ell = 0.\n\nlmax::Integer: the maximum ℓ coefficient, will default to length(cl)-1 if not specified.\nmmax::Integer: the maximum m coefficient, will default to lmax if not specified.\nrng::AbstractRNG : (optional) the RNG to be used for generating the a_ell m. It allows\n\nto set the seed beforehand guaranteeing the reproducibility of the process.\n\n\n\n\n\n","category":"function"},{"location":"Cl/#Generating-a-map-from-power-spectrum","page":"Power Spectrum","title":"Generating a map from power spectrum","text":"","category":"section"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"Synthesize a set of Alm through 'synalm' and generates a map from it through 'alm2map'.","category":"page"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"synfast!\nsynfast","category":"page"},{"location":"Cl/#Healpix.synfast!","page":"Power Spectrum","title":"Healpix.synfast!","text":"synfast!(cl::Vector{T}, map::HealpixMap{T, RingOrder}, lmax::Integer, rng::AbstractRNG) where {T <: Real}\nsynfast!(cl::Vector{T}, map::HealpixMap{T, RingOrder}, lmax::Integer) where {T <: Real}\nsynfast!(cl::Vector{T}, map::HealpixMap{T, RingOrder}, rng::AbstractRNG) where {T <: Real}\nsynfast!(cl::Vector{T}, map::HealpixMap{T, RingOrder}) where {T <: Real}\n\nGenerate a map from a given power spectra C_ell. The result is saved into the HealpixMap passed in input.\n\nArguments:\n\ncl::AbstractVector{T}: The array representing the power spectrum components C_ell.\nmap::HealpixMap{T, RingOrder}: the map that will contain the result.\nlmax::Integer: the maximum ℓ coefficient, will default to length(cl)-1 if not specified.\nrng::AbstractRNG : (optional) the RNG to be used for generating the a_ell m. It allows\n\nto set the seed beforehand guaranteeing the reproducibility of the process.\n\n\n\n\n\n","category":"function"},{"location":"Cl/#Healpix.synfast","page":"Power Spectrum","title":"Healpix.synfast","text":"synfast(cl::Vector{T}, nside::Integer, lmax::Integer, rng::AbstractRNG) where {T <: Real}\nsynfast(cl::Vector{T}, nside::Integer, lmax::Integer) where {T <: Real}\nsynfast(cl::Vector{T}, nside::Integer, rng::AbstractRNG) where {T <: Real}\nsynfast(cl::Vector{T}, nside::Integer) where {T <: Real}\n\nGenerate a HealpixMap with given Nside, from a given power spectra C_ell.\n\nArguments:\n\ncl::AbstractVector{T}: The array representing the power spectrum components C_ell.\nnside::Integer: nside of the map that will contain the result.\nlmax::Integer: the maximum ℓ coefficient, will default to length(cl)-1 if not specified.\nrng::AbstractRNG : (optional) the RNG to be used for generating the a_ell m. It allows\n\nto set the seed beforehand guaranteeing the reproducibility of the process.\n\n\n\n\n\n","category":"function"},{"location":"Cl/#Computing-the-power-spectrum-from-a-map","page":"Power Spectrum","title":"Computing the power spectrum from a map","text":"","category":"section"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"Compute the (cross-) power spectrum of one (or two) 'HealpixMap'.","category":"page"},{"location":"Cl/","page":"Power Spectrum","title":"Power Spectrum","text":"anafast","category":"page"},{"location":"Cl/#Healpix.anafast","page":"Power Spectrum","title":"Healpix.anafast","text":"anafast(map::HealpixMap{Float64, RingOrder, AA}; lmax=nothing, mmax=nothing, niter::Integer = 3) where {T <: Real,AA <: AbstractArray{T,1}} -> Vector{Float64}\nanafast(map₁::HealpixMap{Float64, RingOrder, AA}, map₂::HealpixMap{Float64, RingOrder, AA}; lmax=nothing, mmax=nothing, niter::Integer = 3) where {T <: Real,AA <: AbstractArray{T,1}} -> Vector{Float64}\n\nComputes the power spectrum of a Healpix map, or the cross-spectrum between two maps if map2 is given. No removal of monopole or dipole is performed. The input maps must be in ring-ordering.\n\nArguments:\n\nmap₁::HealpixMap{Float64, RingOrder, AA}: the spherical harmonic coefficients of the first field\nmap₂::HealpixMap{Float64, RingOrder, AA}: the spherical harmonic coefficients of the second field\n\nReturns:\n\nArray{T} containing C_ell, with the first element referring to ℓ=0.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"mapfunc/#Map-functions","page":"Map functions","title":"Map functions","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Functions like pix2angNest and ang2pixNest fully define the Healpix tessellation scheme. They are however extremely impractical in a number of situations. It happens often that a large fraction of pixels in a map need to be processed together. Healpix.jl introduces the HealpixMap{T, O <: Order} type, which acts as a collection of all the pixels on the sphere. A HealpixMap type holds the value of all the pixels in its pixels field, and it keeps track of the ordering (either RING or NESTED). Here is an example that shows how to create a map and initialize it:","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"nside = 32\nm = HealpixMap{Float64, RingOrder}(nside)\nm.pixels[:] = 1.0  # Set all pixels to 1","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Healpix.jl defines the basic operations on maps (sum, subtraction, multiplication, division). These operations can either combine two maps or a map and a scalar value:","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"mollweide(m * 2.0)\nmollweide(m * m)","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"The HealpixMap{T, O <: Order} is derived from the abstract type AbstractHealpixMap{T}, which does not encode the ordering. It is useful for functions that can either work on ring/nested-ordered maps but cannot be executed on plain generic arrays:","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"# Return the number of pixels in the map, regardless of its ordering\nmaplength(m::AbstractHealpixMap{T}) where T = length(m)\n\n# This returns 12\nmaplength(HealpixMap{Float64, RingOrder}(1))\n\n# This too returns 12\nmaplength(HealpixMap{Float64, NestedOrder}(1))\n\n# This fails\nmaplength(zeros(Float64, 12))","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Healpix.jl implements the PolarizedHealpixMap{T, O <: Order} type as well, which derives from AbstractPolarizedHealpixMap{T}. This encodes three maps containing the I/Q/U signal: the intensity (I), and the Q and U Stokes parameters. The three maps must have the same resolution.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"AbstractHealpixMap\nHealpixMap\nAbstractPolarizedHealpixMap\nPolarizedHealpixMap","category":"page"},{"location":"mapfunc/#Healpix.AbstractHealpixMap","page":"Map functions","title":"Healpix.AbstractHealpixMap","text":"AbstractHealpixMap{T} <: AbstractArray{T, 1}\n\nAn abstract type representing an Healpix map without a specified ordering. This can be used to implement multiple dispatch when you don't care about the ordering of a map.\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Healpix.HealpixMap","page":"Map functions","title":"Healpix.HealpixMap","text":"struct HealpixMap{T, O <: Order, AA <: AbstractArray{T, 1}} <: AbstractHealpixMap{T}\n\nA Healpix map. The type T is used for the value of the pixels in a map, and it can be anything (even a string!). The type O is used to specify the ordering of the pixels, and it can either be RingOrder or NestedOrder. The type AA is used to store the array of pixels; typical types are Vector, CUArray, SharedArray, etc.\n\nA HealpixMap type contains the following fields:\n\npixels: array of pixels\nresolution: instance of a Resolution object\n\nYou can construct a map using one of the following forms:\n\nHealpixMap{T, O, AA}(arr) and HealpixMap{T, O, AA}(nside::Number) will use AA as basetype\nHealpixMap{T, O}(arr) and HealpixMap{T, O}(nside::Number) will use Array{T, 1} as basetype\n\nExamples\n\nThe following example creates a map with NSIDE=32 in RING order, containing integer values starting from 1:\n\nmymap = Healpix.HealpixMap{Int64, Healpix.RingOrder}(1:Healpix.nside2npix(32))\n\nThe call to collect is required to convert the range in an array.\n\nThis example creates a map in NESTED order, with NSIDE=64, filled with zeroes:\n\nmymap = Healpix.HealpixMap{Float64, Healpix.NestedOrder}(64)\n\nFinally, the following examples show how to use SharedArray:\n\nusing SharedArrays\n\n# Create a map with all pixels set to zero\nmymap = Healpix.HealpixMap{Float64, Healpix.NestedOrder, SharedArray{Float64, 1}}(64)\n\n# Create a map and initialize pixel values with a SharedArray\npixels = SharedArray{Int64, 1}(1:12 |> collect)\nmymap = Healpix.HealpixMap{Int64, Healpix.RingOrder, SharedArray{Int64, 1}}(m)\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Healpix.AbstractPolarizedHealpixMap","page":"Map functions","title":"Healpix.AbstractPolarizedHealpixMap","text":"AbstractPolarizedHealpixMap{T}\n\nAn abstract type representing an Healpix polarized map without a specified ordering. This can be used to implement multiple dispatch when you don't care about the ordering of a map.\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Healpix.PolarizedHealpixMap","page":"Map functions","title":"Healpix.PolarizedHealpixMap","text":"mutable struct PolarizedHealpixMap{T, O <: Healpix.Order, AA <: AbstractArray{T, 1}}\n\nA polarized I/Q/U map. It contains three Healpix maps with the same NSIDE:\n\ni\nq\nu\n\nYou can create an instance of this type using the function PolarizedHealpixMap{T,O}, which comes in three flavours:\n\nPolarizedHealpixMap(i::HealpixMap{T,O,AA}, q::HealpixMap{T,O,AA}, u::HealpixMap{T,O,AA})\nPolarizedHealpixMap{T,O}(i::AbstractVector{T}, q::AbstractVector{T}, u::AbstractVector{T})\nPolarizedHealpixMap{T,O}(nside::Number)\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Unseen-pixels-and-nothingness","page":"Map functions","title":"Unseen pixels and nothingness","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"You can use the constant UNSEEN to mark unseen pixels, i.e., pixels that lack data associated with them, in a way that is compatible with other Healpix libraries.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"using Healpix  # hide\nm = HealpixMap{Float32, RingOrder}(32)\n\n# Mark all the pixels in the map as «unseen» (missing)\nm[:] .= UNSEEN","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"However, Julia provides a nicer way to denote missing pixels through the use of Nothing (type) and nothing (value). Whenever you pass a Union{Nothing, T} type to a Healpix map, the map will be initialized to nothing, and you can test if a pixel has been observer or not using Julia's function isnothing:","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"using Healpix  # hide\nm = HealpixMap{Union{Int32, Nothing}, RingOrder}(1)\n\nm[:] = 1:12\nm[5] = nothing\n@assert isnothing(m[5])","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Note that, unlike UNSEEN, this mechanism permits to signal «missing» pixels even for maps that do not use floating-point numbers.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"warning: Type stability and Nothing\nUsing Union{Nothing, T} as the base type of a Healpix map can lead to elegant code, but it is not likely to be efficient!For instance, consider two implementations of the same code, which sums all the pixels in a map that are not marked as nothing or UNSEEN:function sumpixels(m::HealpixMap{Union{Nothing, T}, O}) where {T <: Real, O <: Order}\n   cumsum = zero(Float64)\n   @inbounds for i in eachindex(m)\n       (!isnothing(m[i])) && (cumsum += m[i])\n   end\n   cumsum\nend\n\nfunction sumpixels(m::HealpixMap{T, O}) where {T <: Real, O <: Order}\n   cumsum = zero(Float64)\n   @inbounds for i in eachindex(m)\n       (m[i] != UNSEEN) && (cumsum += m[i])\n   end\n   cumsum\nendLet's now create two maps with random values and 50% of their pixels marked either as nothing or UNSEEN:import Random\nmnothing = HealpixMap{Union{Float64, Nothing}, RingOrder}(1024)\nmnothing[:] = rand(length(mnothing))\n@. mnothing[mnothing < 0.5] = nothing\n\n# Create a new map identical to `mnothing`, but use UNSEEN instead of nothing\nm = HealpixMap{Float64, RingOrder}(mnothing.resolution.nside)\nm[:] = [isnothing(x) ? UNSEEN : x for x in mnothing]Running sumpixels over the two maps shows that the version with UNSEEN is three times faster.julia> @benchmark sumpixels(mnothing)\n@benchmark sumpixels(m)\nBenchmarkTools.Trial: 56 samples with 1 evaluation.\n Range (min … max):  88.233 ms …  91.043 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     89.187 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   89.315 ms ± 502.629 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n                  █ █  ▂ █▅▅                                    \n  ▅▁▁▁▁▁▁▁▁█▁▁▁▁▁▁█▁█▅██▁███▅█▅██▅█▅▁▅▁▅▁▁▁▁▁▅█▁█▅▁▁▁▁▅▅▁▁▁▁▁▅ ▁\n  88.2 ms         Histogram: frequency by time         90.5 ms <\n\n Memory estimate: 16 bytes, allocs estimate: 1.\n\njulia> @benchmark sumpixels(m)\nBenchmarkTools.Trial: 201 samples with 1 evaluation.\n Range (min … max):  22.579 ms … 29.701 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     24.213 ms              ┊ GC (median):    0.00%\n Time  (mean ± σ):   24.906 ms ±  1.939 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n   ▁ ▃█▁▁▅▁▃▁       ▂                                  ▁       \n  ▅█▆█████████▄▆█▁█▅█▆█▃▄█▄▄▃▁▃▆▁▃▃▁▄▃▃▄▁▄▇█▅▁▁▁▁▆▃▃▄▅▄█▅▃▃▁▃ ▄\n  22.6 ms         Histogram: frequency by time        29.2 ms <\n\n Memory estimate: 16 bytes, allocs estimate: 1.This happens because the implementation of sumpixels that uses nothing values is not type-stable. You should decide if the elegance of using nothing in your code is worth this degradation in performance or not.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"You can use saveToFITS or readMapFromFITS on maps whose base type is Union{Nothing, T} only if T is a floating-point number, because for the sake of compatibility with other Healpix libraries the FITS file will use UNSEEN to mark missing values.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"UNSEEN","category":"page"},{"location":"mapfunc/#Healpix.UNSEEN","page":"Map functions","title":"Healpix.UNSEEN","text":"A constant commonly used by Healpix libraries to mark «missing» pixels.\n\nThis constant is useful if you need compatibility with other Healpix libraries.\n\n\n\n\n\n","category":"constant"},{"location":"mapfunc/#Encoding-the-order","page":"Map functions","title":"Encoding the order","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Healpix.jl distinguishes between RING and NEST orderings using Julia's typesystem. The abstract type Order has two descendeants, RingOrder and NestedOrder, which are used to instantiate objects of type HealpixMap. Applying the functions nest2ring and  ring2nest to maps converts those maps to the appropriate orders. In-place nest2ring! and ring2nest! versions are also  available.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Order\nRingOrder\nNestedOrder\nnest2ring(m_nest::HealpixMap{T, NestedOrder, AA}) where {T, AA}\nring2nest(m_ring::HealpixMap{T, RingOrder, AA}) where {T, AA}\nnest2ring!(m_ring_dst::HealpixMap{T, RingOrder, AAR}, \n  m_nest_src::HealpixMap{T, NestedOrder, AAN}) where {T, AAN, AAR}\nring2nest!(m_nest_dst::HealpixMap{T, NestedOrder, AAN}, \n  m_ring_src::HealpixMap{T, RingOrder, AAR}) where {T, AAR, AAN}","category":"page"},{"location":"mapfunc/#Healpix.Order","page":"Map functions","title":"Healpix.Order","text":"Abstract type representing the ordering of pixels in a Healpix map. See also RingOrder and NestedOrder.\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Healpix.RingOrder","page":"Map functions","title":"Healpix.RingOrder","text":"The RingOrder type should be used when creating HealpixMap types in order to specify that the pixels in the map are sorted in ring ordering. (See also NestedOrder.)\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Healpix.NestedOrder","page":"Map functions","title":"Healpix.NestedOrder","text":"The NestedOrder type should be used when creating HealpixMap types in order to specify that the pixels in the map are sorted in ring ordering. (See also RingOrder.)\n\n\n\n\n\n","category":"type"},{"location":"mapfunc/#Healpix.nest2ring-Union{Tuple{HealpixMap{T, NestedOrder, AA}}, Tuple{AA}, Tuple{T}} where {T, AA}","page":"Map functions","title":"Healpix.nest2ring","text":"nest2ring(m_nest::HealpixMap{T, NestedOrder, AA}) where {T, AA}\n\nConvert a map from nested to ring order. This version allocates a new array of the same array type as the input.\n\nArguments:\n\nm_nest::HealpixMap{T, NestedOrder, AA}: map of type NestedOrder\n\nReturns:\n\nHealpixMap{T, RingOrder, AA}: the input map converted to RingOrder\n\nExamples\n\njulia> m_nest = HealpixMap{Float64,NestedOrder}(rand(nside2npix(64)));\n\njulia> nest2ring(m_nest)\n49152-element HealpixMap{Float64, RingOrder, Vector{Float64}}:\n 0.4703834205807309\n ⋮\n 0.3945848051663148\n\n\n\n\n\n","category":"method"},{"location":"mapfunc/#Healpix.ring2nest-Union{Tuple{HealpixMap{T, RingOrder, AA}}, Tuple{AA}, Tuple{T}} where {T, AA}","page":"Map functions","title":"Healpix.ring2nest","text":"ring2nest(m_ring::HealpixMap{T, RingOrder, AA}) where {T, AA}\n\nConvert a map from ring to nested order. This version allocates a new array of the same array type as the input.\n\nArguments:\n\nm_ring::HealpixMap{T, RingOrder, AA}: map of type RingOrder\n\nReturns:\n\nHealpixMap{T, NestedOrder, AA}: the input map converted to NestedOrder\n\nExamples\n\njulia> m_ring = HealpixMap{Float64,RingOrder}(rand(nside2npix(64)));\n\njulia> ring2nest(m_ring)\n49152-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:\n 0.0673134062168923\n ⋮\n 0.703460503535335\n\n\n\n\n\n","category":"method"},{"location":"mapfunc/#Healpix.nest2ring!-Union{Tuple{AAR}, Tuple{AAN}, Tuple{T}, Tuple{HealpixMap{T, RingOrder, AAR}, HealpixMap{T, NestedOrder, AAN}}} where {T, AAN, AAR}","page":"Map functions","title":"Healpix.nest2ring!","text":"nest2ring!(m_ring_dst::HealpixMap{T, RingOrder, AAR},\n           m_nest_src::HealpixMap{T, NestedOrder, AAN}) where {T, AAN, AAR}\n\nConvert a map from nested to ring order. This version takes a nested map in the second argument and writes it to the nested map provided in the first argument, following the standard Julia func!(dst, src) convention.\n\nArguments:\n\nm_ring_dst::HealpixMap{T, NestedOrder, AA}: map of type NestedOrder\nm_nest_src::HealpixMap{T, NestedOrder, AAN}: map of type RingOrder\n\nReturns:\n\nHealpixMap{T, RingOrder, AA}: the input map converted to RingOrder\n\nExamples\n\njulia> m_nest = HealpixMap{Float64,NestedOrder}(rand(nside2npix(64)));\n\njulia> m_ring = HealpixMap{Float64,RingOrder}(64);\n\njulia> nest2ring!(m_ring, m_nest)\n49152-element HealpixMap{Float64, RingOrder, Vector{Float64}}:\n 0.33681791815569895\n ⋮\n 0.9092457003948482\n\n\n\n\n\n","category":"method"},{"location":"mapfunc/#Healpix.ring2nest!-Union{Tuple{AAN}, Tuple{AAR}, Tuple{T}, Tuple{HealpixMap{T, NestedOrder, AAN}, HealpixMap{T, RingOrder, AAR}}} where {T, AAR, AAN}","page":"Map functions","title":"Healpix.ring2nest!","text":"ring2nest!(m_nest_dst::HealpixMap{T, NestedOrder, AAN},\n           m_ring_src::HealpixMap{T, RingOrder, AAR}) where {T, AAR, AAN}\n\nConvert a map from ring to nested order. This version takes a nested map in the second argument and writes it to the nested map provided in the first argument, following the standard Julia func!(dst, src) convention.\n\nArguments:\n\nm_nest_dst::HealpixMap{T, NestedOrder, AAN}: map of type RingOrder\nm_ring_src::HealpixMap{T, RingOrder, AA}: map of type RingOrder\n\nReturns:\n\nHealpixMap{T, NestedOrder, AA}: the input map converted to NestedOrder\n\nExamples\n\njulia> m_ring = HealpixMap{Float64,RingOrder}(rand(nside2npix(64)));\n\njulia> m_nest = HealpixMap{Float64,RingOrder}(64);\n\njulia> ring2nest!(m_nest, m_ring)\n49152-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:\n 0.0673134062168923\n ⋮\n 0.703460503535335\n\n\n\n\n\n","category":"method"},{"location":"mapfunc/#Pixel-functions","page":"Map functions","title":"Pixel functions","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"When working with maps, it is not needed to pick between ang2pixNest and ang2pixRing because a HealpixMap type already encodes the ordering. Functions pix2ang and ang2pix always choose the correct ordering, but they require a HealpixMap instead of a Resolution as their first argument.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"pix2ang\nang2pix","category":"page"},{"location":"mapfunc/#Healpix.pix2ang","page":"Map functions","title":"Healpix.pix2ang","text":"pix2ang{T, O <: Order}(map::HealpixMap{T, O}, ipix) -> (Float64, Float64)\npix2ang{T, O <: Order}(map::PolarizedHealpixMap{T, O}, ipix) -> (Float64, Float64)\n\nReturn the pair (theta, phi), where theta is the colatitude and phi the longitude of the direction of the pixel center with index ipix.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Healpix.ang2pix","page":"Map functions","title":"Healpix.ang2pix","text":"ang2pix{T, O, AA}(map::HealpixMap{T, O}, theta, phi)\nang2pix{T, O, AA}(map::PolarizedHealpixMap{T, O}, theta, phi)\n\nConvert the direction specified by the colatitude theta (∈ [0, π]) and the longitude phi (∈ [0, 2π]) into the index of the pixel in the Healpix map map.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Loading-and-saving-maps","page":"Map functions","title":"Loading and saving maps","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Healpix.jl implements a number of functions to save maps in FITS files.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"saveToFITS","category":"page"},{"location":"mapfunc/#Healpix.saveToFITS","page":"Map functions","title":"Healpix.saveToFITS","text":"saveToFITS(map::HealpixMap{T, O}, filename::AbstractString, typechar=\"D\", unit=\"\", extname=\"MAP\") where {T <: Number, O <: Order}\nsaveToFITS(map::PolarizedHealpixMap{T, O}, filename::AbstractString, typechar=\"D\", unit=\"\", extname=\"MAP\") where {T <: Number, O <: Order}\n\nSave a map into a FITS file. The name of the file is specified in filename; if it begins with !, existing files will be overwritten without warning. The parameter typechar specifies the data type to be used in the FITS file: the default (D) will save 64-bit floating-point values. See the CCFITSIO documentation for other values. The keyword unit specifies the measure unit used for the pixels in the map. The keyword extname specifies the name of the HDU where the map pixels will be written.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Function savePixelsToFITS is a low-level function. It knows nothing about the ordering schema used for the pixels, so the caller should manually write the ORDERING keyword in the HDU header by itself.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"savePixelsToFITS","category":"page"},{"location":"mapfunc/#Healpix.savePixelsToFITS","page":"Map functions","title":"Healpix.savePixelsToFITS","text":"savePixelsToFITS(map::HealpixMap{T}, f::CFITSIO.FITSFile, column) where {T <: Number}\n\nSave the pixels of map into the column with index/name column in the FITS file, which must have been already opened.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"To load a map from a FITS file, you can either use readMapFromFITS or readPolarizedMapFromFITS.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"readMapFromFITS\nreadPolarizedMapFromFITS","category":"page"},{"location":"mapfunc/#Healpix.readMapFromFITS","page":"Map functions","title":"Healpix.readMapFromFITS","text":"readMapFromFITS{T}(f::CFITSIO.FITSFILE, column, t::Type{T})\nreadMapFromFITS{T}(fileName::String, column, t::Type{T})\n\nRead a Healpix map from the specified (1-base indexed) column in a FITS file. The values will be read as numbers of type T. If the code fails, CFITSIO will raise an exception. (Refer to the CFITSIO library for more information.)\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Healpix.readPolarizedMapFromFITS","page":"Map functions","title":"Healpix.readPolarizedMapFromFITS","text":"readPolarizedMapFromFITS{T}(fileName::AbstractString, column, t::Type{T})\n\nRead a polarized map (I/Q/U) from a FITS file and return a PolarizedHealpixMap object.\n\nThe parameter column can be either a number or a 3-element tuple. In the first case, three consecutive columns will be read starting from column (1-based index), otherwise the three column indices will be used.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Testing-for-conformability","page":"Map functions","title":"Testing for conformability","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"It often happens that two Healpix maps need to be combined together: for instance, pixels on a sky map might need to be masked using a sky mask, or one map might need to be subtracted from another one. «Conformability» means that the operation between the two maps can be done directly on the pixels, without oordering or resolution conversions. The function conformables checks this.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"using Healpix # hide\nm1 = HealpixMap{Float64, RingOrder}(1)\nm2 = HealpixMap{Float64, RingOrder}(1)\nm3 = HealpixMap{Float64, NestedOrder}(1)\nm4 = HealpixMap{Float64, NestedOrder}(2)\nconformables(m1, m2)\nconformables(m1, m3)\nconformables(m1, m4)","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"conformables","category":"page"},{"location":"mapfunc/#Healpix.conformables","page":"Map functions","title":"Healpix.conformables","text":"conformables{T, S, O1, O2}(map1::HealpixMap{T, O1, AA1},\n                           map2::HealpixMap{S, O2, AA2}) -> Bool\nconformables{T, S, O1, O2}(map1::PolarizedHealpixMap{T, O1, AA1},\n                           map2::PolarizedHealpixMap{S, O2, AA2}) -> Bool\n\nDetermine if two Healpix maps are \"conformables\", i.e., if their shape and ordering are the same. The array types AA1 and AA2 are not considered in testing conformability.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Interpolation","page":"Map functions","title":"Interpolation","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"The fact that a Healpix map is, well, pixelized means that there is a sharp boundary between adjacent pixels. This can lead to undesidable effects, and therefore Healpix.jl provides a function, interpolate, that returns the interpolated value of the map along some direction in the sky:","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"If the direction (θ, ɸ) passes through the center of a pixel, interpolate returns the value of the pixel itself;\nOtherwise, the value of the pixel and its neighbours will be interpolated using a linear function to return a weighted value.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"interpolate","category":"page"},{"location":"mapfunc/#Healpix.interpolate","page":"Map functions","title":"Healpix.interpolate","text":"interpolate(m::HealpixMap{T, RingOrder, AA}, θ, ϕ) -> Value\ninterpolate(m::HealpixMap{T, RingOrder, AA}, θ, ϕ, pixbuf, weightbuf) -> Value\n\nReturn an interpolated value of the map along the specified direction.\n\nWhen provided, the parameters pixbuf and weightbuf must be 4-element arrays of integer and floating-point values, respectively. They can be reused across multiple calls of interpolate, to save heap allocations, and they do not need to be initialized, as they are used internally:\n\npixbuf = Array{Int}(undef, 4)\nweightbuf = Array{Float64}(undef, 4)\n\nm = HealpixMap{Float64, RingOrder}(1)\nfor (θ, ϕ) in [(0., 0.), (π/2, π/2)]\n    println(interpolate(m, θ, ϕ, pixbuf, weightbuf))\nend\n\nPassing pixbuf and weightbuf saves some time, as this simple benchmark shows:\n\njulia> @benchmark interpolate(m, rand(), rand(), pixbuf, weightbuf)\nBenchmarkTools.Trial:\n  memory estimate:  618 bytes\n  allocs estimate:  9\n  --------------\n  minimum time:     283.184 ns (0.00% GC)\n  median time:      296.140 ns (0.00% GC)\n  mean time:        348.132 ns (9.55% GC)\n  maximum time:     10.627 μs (95.88% GC)\n  --------------\n  samples:          10000\n  evals/sample:     282\n\njulia> @benchmark interpolate(m, rand(), rand())\nBenchmarkTools.Trial:\n  memory estimate:  837 bytes\n  allocs estimate:  11\n  --------------\n  minimum time:     329.825 ns (0.00% GC)\n  median time:      345.504 ns (0.00% GC)\n  mean time:        417.004 ns (11.04% GC)\n  maximum time:     13.733 μs (96.21% GC)\n  --------------\n  samples:          10000\n  evals/sample:     223\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Upgrading-and-Downgrading","page":"Map functions","title":"Upgrading and Downgrading","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Changing resolution is done with udgrade. This is very fast for nested orderings, but slow for ring ordering.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"udgrade","category":"page"},{"location":"mapfunc/#Healpix.udgrade","page":"Map functions","title":"Healpix.udgrade","text":"udgrade(input_map::HealpixMap{T,O,AA}, output_nside; kw...) where {T,O,AA} -> HealpixMap{T,O,AA}\n\nUpgrades or downgrades a map to a target nside. Always makes a copy. This is very fast for nested orderings, but slow for ring because one needs to transform to nested ordering first.\n\nArguments:\n\ninput_map::HealpixMap{T,O,AA}: the map to upgrade/downgrade\noutput_nside: desired nside\n\nKeywords:\n\nthreshold=abs(1e-6UNSEEN): absolute tolerance for identifying a bad pixel vs UNSEEN\npess=false: if false, estimate pixels from remaining good pixels when downgrading.   if true, the entire downgraded pixel is set to UNSEEN.\n\nReturns:\n\nHealpixMap{T,O,AA}: upgraded/downgraded map in the same ordering as the input\n\nExamples\n\njulia> A = HealpixMap{Float64, NestedOrder}(ones(nside2npix(4)))\n192-element HealpixMap{Float64, RingOrder, Vector{Float64}}:\n 1.0\n ⋮\n 1.0\n\njulia> Healpix.udgrade(A, 2)\n48-element HealpixMap{Float64, NestedOrder, Vector{Float64}}:\n 1.0\n ⋮\n 1.0\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Map-making","page":"Map functions","title":"Map-making","text":"","category":"section"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Map-making is the process of converting a time series of measurements into a sky map. The most basic form of map-making is the so-called \"binning\", where samples in the time stream falling within the same sky pixel are averaged. This map-making algorithm is strictly accurate only if the noise in the time stream is white.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"Healpix.jl implements two functions to perform binning, tod2map and combinemaps!.","category":"page"},{"location":"mapfunc/","page":"Map functions","title":"Map functions","text":"tod2map\ncombinemaps!","category":"page"},{"location":"mapfunc/#Healpix.tod2map","page":"Map functions","title":"Healpix.tod2map","text":"tod2map{T,O}(pixidx, tod::Array{T}; nside=128) :: (map, hits)\n\nCreate a binned map for a TOD and return a tuple containing the map itself and the hit map.\n\n\n\n\n\n","category":"function"},{"location":"mapfunc/#Healpix.combinemaps!","page":"Map functions","title":"Healpix.combinemaps!","text":"combinemaps{T, O, H}(destmap::HealpixMap{T, O}, desthitmap::HealpixMap{H, O}, othermap::HealpixMap{T, O}, otherhitmap::HealpixMap{H, O})\n\nSum \"othermap\" to \"destmap\", assuming that both maps have been produced by binning TODs. The parameters desthitmap and otherhitmap are the two hit maps. At the end of the call, destmap and desthitmap are updated.\n\n\n\n\n\n","category":"function"},{"location":"misc/","page":"Miscellanea","title":"Miscellanea","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"misc/#General-purpose-functions","page":"Miscellanea","title":"General-purpose functions","text":"","category":"section"},{"location":"misc/","page":"Miscellanea","title":"Miscellanea","text":"Healpix.jl implements a few generic functions that can be helpful when doing calculations on the sphere.","category":"page"},{"location":"misc/","page":"Miscellanea","title":"Miscellanea","text":"lat2colat\ncolat2lat","category":"page"},{"location":"misc/#Healpix.lat2colat","page":"Miscellanea","title":"Healpix.lat2colat","text":"lat2colat(x)    colat2lat(x)\n\nConvert colatitude into latitude and vice versa. Both x and the result are expressed in radians.\n\n\n\n\n\n","category":"function"},{"location":"misc/#Healpix.colat2lat","page":"Miscellanea","title":"Healpix.colat2lat","text":"lat2colat(x)    colat2lat(x)\n\nConvert colatitude into latitude and vice versa. Both x and the result are expressed in radians.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"pixelfunc/#Pixel-functions","page":"Pixel functions","title":"Pixel functions","text":"","category":"section"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"In this section we document the functions that convert from a direction in the sky into a pixel index, and vice versa.","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"First of all, Healpix.jl implements the most basic functions to convert between spherical and Cartesian coordinates. Note that Healpix uses co-latitude instead of latitude:","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"using Healpix # hide\nang2vec(0.0, 0.0)\nvec2ang(0.0, 0.0, 1.0)","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"More interesting functions return the index of the pixel on a Healpix-tessellated sphere. For these functions to work, you have to provide a Resolution object:","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"res = Resolution(16)\nang2pixRing(res, π/2, 0)\nang2pixNest(res, π/2, 0)","category":"page"},{"location":"pixelfunc/#Ring-functions","page":"Pixel functions","title":"Ring functions","text":"","category":"section"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"The Healpix projection has the advantage of storing pixels along iso-latitude rings; this allows to implement efficient spherical-transform functions. Healpix.jl provides a number of functions that manage rings. Many of them use the RingInfo structure, which encodes details about a ring.","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"RingInfo\ngetringinfo\ngetringinfo!\ngetinterpolRing","category":"page"},{"location":"pixelfunc/#Healpix.RingInfo","page":"Pixel functions","title":"Healpix.RingInfo","text":"RingInfo\n\nInformation about a ring of pixels, i.e., the set of pixels on a Healpix map which have the same colatitude. The type is \"mutable\", so that one object can begin reused many times without further memory allocations.\n\nThe list of fields defined in this structure is the following:\n\nring: an integer index, running from \nfirstPixIdx: index of the first pixel (using the RING scheme) belonging to this ring\nnumOfPixels: number of consecutive pixels within the ring\ncolatitude_rad: value of the colatitude for this ring (in radians)\nshifted: Boolean flag; it is true if the longitude of the first pixel in the ring is not zero.\n\nReferences\n\nSee also getringinfo! and getringinfo.\n\nExample\n\nimport Healpix\nres = Healpix.Resolution(256)\n\n# Show information about ring #10\nprint(getringinfo(res, 10))\n\n\n\n\n\n","category":"type"},{"location":"pixelfunc/#Healpix.getringinfo","page":"Pixel functions","title":"Healpix.getringinfo","text":"getringinfo(resol::Resolution, ring; kwargs...) :: RingInfo\n\nReturn a RingInfo structure containing information about the specified ring. For the list of accepted keyword arguments, see getringinfo!.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/#Healpix.getringinfo!","page":"Pixel functions","title":"Healpix.getringinfo!","text":"getringinfo!(resol::Resolution, ring, ringinfo::RingInfo; full=true) :: RingInfo\n\nFill the RingInfo structure with information about the specified ring. If full is false, the field colatitude_rad (the most expensive in terms of computation) is set to NaN.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/#Healpix.getinterpolRing","page":"Pixel functions","title":"Healpix.getinterpolRing","text":"getinterpolRing(resol::Resolution, θ, ϕ) -> (Array{Int,1}, Array{Float64, 1})\ngetinterpolRing!(resol::Resolution, θ, ϕ, pix, weights) -> (Array{Int,1}, Array{Float64, 1})\n\nReturn the indices and the weights of the four neighbour pixels for the given direction (θ, ϕ) in a map with the specified resolution.\n\nIf provided, the parameters pix and weights should point to two 4-element arrays of integers and floating-points, respectively. They can be reused in multiple calls to avoid heap allocations and speed up the code.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/#Pixel-boundaries","page":"Pixel functions","title":"Pixel boundaries","text":"","category":"section"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"It is sometimes useful to be able to trace the border of a pixel: this can be useful for plotting purposes. Healpix.jl implements the boundariesRing! and boundariesRing functions for this purpose. They calculate a set of N vectors pointing to a number of points along the border of a given pixel and return them as a Ntimes 3 matrix.","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"Here is a visual example:","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"using Plots\npyplot() # hide\nusing Healpix # hide\n\npointsperside = 10\nmatr = boundariesRing(Resolution(2), 3, pointsperside, Float32)\nscatter(matr[:, 1], matr[:, 2], matr[:, 3])\nsavefig(joinpath(\"images\", \"pixelboundaries1.png\")) # hide","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"(Image: )","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"We can cycle this over all the pixels in a map; however, using boundariesRing will require the result matrix to be allocated again and again for each pixel. Here boundariesRing! comes to the rescue, as we can pre-allocate the matrix and then pass it to each call within the for loop:","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"using Plots\npyplot() # hide\nusing Healpix # hide\n\npointsperside = 10\nmatr = Matrix{Float32}(undef, 4pointsperside, 3)\nresol = Resolution(2)\n\nscatter()\nfor pixidx in 1:resol.numOfPixels\n    boundariesRing!(resol, pixidx, pointsperside, matr)\n    scatter!(matr[:, 1], matr[:, 2], matr[:, 3], label=\"\")\nend\nsavefig(joinpath(\"images\", \"pixelboundariesall.png\")) # hide","category":"page"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"(Image: )","category":"page"},{"location":"pixelfunc/#Reference","page":"Pixel functions","title":"Reference","text":"","category":"section"},{"location":"pixelfunc/","page":"Pixel functions","title":"Pixel functions","text":"ang2vec(theta, phi)\nvec2ang(x, y, z)\nang2pixNest(resol::Resolution, theta, phi)\nzphi2pixRing(resol::Resolution, theta, phi)\nang2pixRing(resol::Resolution, theta, phi)\npix2angNest(resol::Resolution, pixel)\npix2angRing(resol::Resolution, pixel)\nring2nest(resol::Resolution, ipix)\nnest2ring(resol::Resolution, ipix)\npix2ringpos(resol::Resolution, pixel)\npix2xyfNest(resol::Resolution, ipix)\npix2xyfRing(resol::Resolution, ipix)\nxyf2pixNest(resol::Resolution, ix, iy, facenum)\nxyf2pixRing(resol::Resolution, ix, iy, facenum)\nxyf2loc\npix2zphiRing(res::Resolution, pix)\npix2zphiNest(res::Resolution, pix)\nringAbove\nring2z\nnumOfRings\nmax_pixrad\nboundariesRing\nboundariesRing!","category":"page"},{"location":"pixelfunc/#Healpix.ang2vec-Tuple{Any, Any}","page":"Pixel functions","title":"Healpix.ang2vec","text":"ang2vec(theta, phi) -> Array{Float64}\n\nGiven a direction in the sky with colatitude theta and longitude phi (in radians), return an array of 3 elements containing the x, y, and z components of the one-length vector pointing to that direction.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.vec2ang-Tuple{Any, Any, Any}","page":"Pixel functions","title":"Healpix.vec2ang","text":"vec2ang(x, y, z) -> (Number, Number)\n\nGiven a vector (not necessarily normalized) whose Cartesian components are x, y, and z, return a pair (theta, phi) containing the colatitude theta and the longitude phi (in radians) of the direction in the sky the vector is pointing at.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.ang2pixNest-Tuple{Resolution, Any, Any}","page":"Pixel functions","title":"Healpix.ang2pixNest","text":"ang2pixNest(resol::Resolution, theta, phi) -> Integer\n\nReturn the index of the pixel which contains the point with coordinates (theta, the colatitude, and phi, the longitude), in radians, for a Healpix map with pixels in nested order. Note that pixel indexes are 1-based (this is Julia)!\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.zphi2pixRing-Tuple{Resolution, Any, Any}","page":"Pixel functions","title":"Healpix.zphi2pixRing","text":"zphi2pixRing(resol::Resolution, theta, phi) -> Integer\n\nReturn the index of the pixel which contains the point with coordinates (theta, the colatitude, and phi, the longitude), in radians, for a Healpix map with pixels in ring order. Note that pixel indexes are 1-based (this is Julia)!\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.ang2pixRing-Tuple{Resolution, Any, Any}","page":"Pixel functions","title":"Healpix.ang2pixRing","text":"ang2pixRing(resol::Resolution, theta, phi) -> Integer\n\nReturn the index of the pixel which contains the point with coordinates (theta, the colatitude, and phi, the longitude), in radians, for a Healpix map with pixels in ring order. Note that pixel indexes are 1-based (this is Julia)!\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2angNest-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2angNest","text":"pix2angNest(resol::Resolution, pixel) -> (Float64, Float64)\n\nGiven the (1-based) index of a pixel in a Healpix map in nested order, return a pair containing the (colatitude, longitude) angles corresponding to its center, both expressed in radians.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2angRing-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2angRing","text":"pix2angRing(resol::Resolution, pixel) -> (Float64, Float64)\n\nGiven the (1-based) index of a pixel in a Healpix map in ring order, return a pair containing the (colatitude, longitude) angles corresponding to its center, both expressed in radians.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.ring2nest-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.ring2nest","text":"ring2nest(resol::Resolution, ipix) :: Int\n\nConvert the number of a pixel from RING to NESTED scheme.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.nest2ring-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.nest2ring","text":"nest2ring(resol::Resolution, ipix) :: Int\n\nConvert the number of a pixel from NESTED to RING scheme.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2ringpos-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2ringpos","text":"pix2ringpos(resol::Resolution, pixel)\n\nGiven the (1-based) index of a pixel in a Healpix map in ring order, return a pair of numbers (n, i, j) whose meaning is the following:\n\nn can be one of the symbols :northcap, :equator, or :southcap, representing the region of the sky\ni is the ring index, from 1 to 4NSIDE - 1\nj is the pixel-in-ring index\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2xyfNest-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2xyfNest","text":"pix2xyfNest(resol::Resolution, ipix) :: (Int, Int, Int)\n\nConvert a pixel number into (x, y, face), using NESTED ordering.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2xyfRing-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2xyfRing","text":"pix2xyfRing(resol::Resolution, ipix) :: (Int, Int, Int)\n\nConvert a pixel number into (x, y, face), using RING ordering.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.xyf2pixNest-Tuple{Resolution, Any, Any, Any}","page":"Pixel functions","title":"Healpix.xyf2pixNest","text":"xyf2pixNest(resol::Resolution, ix, iy, facenum) :: Int\n\nConvert (x, y, face) into a pixel number, using NESTED ordering.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.xyf2pixRing-Tuple{Resolution, Any, Any, Any}","page":"Pixel functions","title":"Healpix.xyf2pixRing","text":"xyf2pixRing(resol::Resolution, ix, iy, facenum) :: Int\n\nConvert (x, y, face) into a pixel number, using RING ordering.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.xyf2loc","page":"Pixel functions","title":"Healpix.xyf2loc","text":"xyf2loc(x, y, face) -> (z, phi, sintheta, have_sintheta)\n\nGiven a position encoded as XYF, return the tuple containing z = cos(theta), \\phi, and optionally an accurate estimate for sin(theta) (if have_sintheta is true), where theta is the colatitude and phi is the longitude, both expressed in radians.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/#Healpix.pix2zphiRing-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2zphiRing","text":"pix2zphiRing(res::Resolution, pix) -> (z, phi)\n\nCompute the angular coordinates z = cos(θ), ϕ of the center of the pixel with number pix, assuming the RING numbering scheme for pixels. Caution: this method is inaccurate near the poles at high resolutions.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.pix2zphiNest-Tuple{Resolution, Any}","page":"Pixel functions","title":"Healpix.pix2zphiNest","text":"pix2zphiNest(res::Resolution, pix) -> (z, phi)\n\nCompute the angular coordinates z = cos(θ), ϕ of the center of the pixel with number pix, assuming the NEST numbering scheme for pixels. Caution: this method is inaccurate near the poles at high resolutions.\n\n\n\n\n\n","category":"method"},{"location":"pixelfunc/#Healpix.ringAbove","page":"Pixel functions","title":"Healpix.ringAbove","text":"ringAbove(res::Resolution, z) -> (ring_number)\n\nReturn the number of the next ring to the north of z = cos(θ). If z lies north of all rings, the function returns 0.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/#Healpix.ring2z","page":"Pixel functions","title":"Healpix.ring2z","text":"ring2z(res::Resolution, ring) -> z\n\nReturn the value of z = \\cos(\\theta) for the given ring.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/#Healpix.numOfRings","page":"Pixel functions","title":"Healpix.numOfRings","text":"numOfRings(resol::Resolution)\nnumOfRings(nside::Integer)\n\nReturn the number of horizontal rings in a Healpix map.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/#Healpix.max_pixrad","page":"Pixel functions","title":"Healpix.max_pixrad","text":"max_pixrad(res::Resolution, ring)\nmax_pixrad(res::Resolution)\n\nReturn the maximum angular distance (in radians) between a pixel center and any of its corners. If ring is specified, the result applies to all the pixels of the given ring; otherwise, all the pixels on the sphere are considered.\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/#Healpix.boundariesRing","page":"Pixel functions","title":"Healpix.boundariesRing","text":"boundariesRing(resol::Resolution, pix, step, T::Type{<:Real})\nboundariesRing!(resol::Resolution, pix, step, buf::Matrix{T}) where {T <: Real}\n\nCompute a set of directions (3D vectors) along the boundaries of a given pixel in the RING scheme at some resolution.\n\nThe function boundariesRing returns a N times 3 matrix of type T containing N vectors pointing towards the border of the pixel with index pix in RING scheme. Each edge of the pixel contains step points, and, as every pixel has a diamond-like shape with four edges, the number N is equal to 4 * step.\n\nIf you plan to call this function again and again, you should allocate your own matrix with the results and call boundariesRing!, which accepts the parameter buf where the result will be stored. The shape of this matrix must be (4step, 3), for instance, and its element can be left undefined:\n\nstep = 10\nbuf = Matrix{Float64}(undef, 4step, 3)\nboundariesRing!(res, pixidx, step, buf)  # This sets `buf`\n\nExamples\n\nHere we show how to use boundariesRing and boundariesRing! together to avoid allocating a matrix twice.\n\njulia> matr = boundariesRing(Resolution(16), 534, 2, Float16)\n8×3 Matrix{Float16}:\n 0.3535  -0.6123  0.707\n 0.3525  -0.6353  0.687\n 0.3513  -0.657   0.6665\n 0.3762  -0.664   0.646\n 0.4014  -0.6694  0.625\n 0.4084  -0.645   0.646\n 0.414   -0.6196  0.6665\n 0.3843  -0.6167  0.687\n\njulia> boundariesRing!(Resolution(16), 535, 2, matr)  # Reuse `matr`\n\njulia> matr\n8×3 Matrix{Float16}:\n 0.4158  -0.5723  0.707\n 0.415   -0.596   0.687\n 0.414   -0.6196  0.6665\n 0.4397  -0.624   0.646\n 0.465   -0.627   0.625\n 0.4697  -0.602   0.646\n 0.473   -0.576   0.6665\n 0.4446  -0.5747  0.687\n\n\n\n\n\n","category":"function"},{"location":"pixelfunc/#Healpix.boundariesRing!","page":"Pixel functions","title":"Healpix.boundariesRing!","text":"boundariesRing!(resol::Resolution, pix, step, buf::Matrix{T}) where {T <: Real}\n\nSee the documentation for boundariesRing.\n\n\n\n\n\n","category":"function"},{"location":"resolutions/","page":"Working with resolutions","title":"Working with resolutions","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"resolutions/#Working-with-resolutions","page":"Working with resolutions","title":"Working with resolutions","text":"","category":"section"},{"location":"resolutions/","page":"Working with resolutions","title":"Working with resolutions","text":"A Healpix tessellation is parametrized by a number, called NSIDE, which must be a positive power of 2. It is related to the number of pixels N in the maps by the simple equation N = 12 mathrmNSIDE^2, and it is therefore related to the resolution of the pixelization. Any function working on a Healpix tessellation needs to receive the value of NSIDE. Healpix.jl provides a wrapper around this parameter, the Resolution type, which internally keeps a number of precomputed coefficients to accelerate calculations.","category":"page"},{"location":"resolutions/","page":"Working with resolutions","title":"Working with resolutions","text":"The following example prints a table containing details about a few Healpix resolutions:","category":"page"},{"location":"resolutions/","page":"Working with resolutions","title":"Working with resolutions","text":"using Healpix # hide\nusing Printf\n\n@printf(\"%-6s\\t%-12s\\t%-12s\\t%-12s\\n\",\n        \"NSIDE\",\n        \"#pix\",\n        \"#pix per face\",\n        \"solid angle\")\nfor poweroftwo in [0, 1, 2, 3, 4, 5]\n    res = Resolution(2 ^ poweroftwo)\n    @printf(\"%6d\\t%12d\\t%12d\\t%12.4f\\n\",\n            res.nside,\n            res.numOfPixels,\n            res.pixelsPerFace,\n            4π / res.numOfPixels)\nend","category":"page"},{"location":"resolutions/","page":"Working with resolutions","title":"Working with resolutions","text":"There is an upper limit to the value of the NSIDE parameter, which is encoded in the constant NSIDE_MAX. The value is determined at runtime according to the size of the Int type; on 32-bit machines it is 8192 (2^13), while on 64-bit machines it is 536870912 (2^29).","category":"page"},{"location":"resolutions/","page":"Working with resolutions","title":"Working with resolutions","text":"Resolution\nResolution(nside::Integer)\nnsideok(nside::Integer)\nnside2npix(nside::Integer)\nnpix2nside(npix::Integer)\nnside2pixarea(nside::Integer)\nnside2resol(nside::Integer)\nnside2order(nside::Integer)\norder2nside(order::Integer)\nORDER_MAX\nNSIDE_MAX","category":"page"},{"location":"resolutions/#Healpix.Resolution","page":"Working with resolutions","title":"Healpix.Resolution","text":"struct Resolution\n\nResolution objects are needed to perform a number of pixel-related functions, e.g., convert a direction into a pixel number and vice versa.\n\nThe fields of a Resolution object are the following:\n\nnside: the NSIDE parameter\nnsideTimesTwo: 2 * NSIDE\nnsideTimesFour: 4 * NSIDE\nnumOfPixels: number of pixels in the map\norder: order of the map\npixelsPerFace: number of pixels in each Healpix face\nncap\nfact2\nfact1\n\n\n\n\n\n","category":"type"},{"location":"resolutions/#Healpix.Resolution-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.Resolution","text":"Resolution(nside) -> Resolution\n\nCreate a Resolution object, given a value for NSIDE.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.nsideok-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.nsideok","text":"nsideok(nside::Integer) -> Bool\n\nCheck whether nside is a valid NSIDE parameter.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.nside2npix-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.nside2npix","text":"nside2npix(nside::Integer) -> Integer\n\nReturn the number of pixels for a Healpix map with the specified NSIDE value. If NSIDE is not an integer power of two, the function throws a DomainError exception.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.npix2nside-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.npix2nside","text":"npix2nside(npix::Integer) -> Integer\n\nGiven the number of pixels in a Healpix map, return the NSIDE resolution parameter. If the number is invalid, throw a DomainError exception.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.nside2pixarea-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.nside2pixarea","text":"nside2pixarea(nside::Integer) -> Real\n\nReturn the solid angle of a pixel in a map with the specified NSIDE parameter. The result is expressed in steradians.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.nside2resol-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.nside2resol","text":"nside2resol(nside::Integer) -> Real\n\nReturn the approximate resolution of a map with the specified NSIDE. The resolution is expressed in radians, and it is the square root of the pixel size.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.nside2order-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.nside2order","text":"nside2order(nside::Integer)\n\nReturn the order (positive integer) associated with a given NSIDE.\n\nIf you have created a Healpix.Resolution object, you can access the order through the field order.\n\nSee also order2nside.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.order2nside-Tuple{Integer}","page":"Working with resolutions","title":"Healpix.order2nside","text":"nside2order(nside::Integer)\n\nReturn the value of NSIDE for a given order.\n\nIf you have created a Healpix.Resolution object, you can access the value of NSIDE through the field nside.\n\nSee also nside2order.\n\n\n\n\n\n","category":"method"},{"location":"resolutions/#Healpix.ORDER_MAX","page":"Working with resolutions","title":"Healpix.ORDER_MAX","text":"ORDER_MAX\n\nMaximum order for the resolution of a map supported on this machine. The value of NSIDE_MAX is equal to 2^ORDER_MAX.\n\n\n\n\n\n","category":"constant"},{"location":"resolutions/#Healpix.NSIDE_MAX","page":"Working with resolutions","title":"Healpix.NSIDE_MAX","text":"NSIDE_MAX\n\nMaximum allowed value for the NSIDE resolution parameter.\n\n\n\n\n\n","category":"constant"},{"location":"visualization/#Visualization-functions","page":"Visualization","title":"Visualization functions","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Healpix.jl uses RecipesBase to display maps. You need to import Plots in order to display maps, using the plot functions.  Maps are internally treated as heatmaps, so your backend should support this kind of visualization: at the moment, this is true for GR, PlotLy and PyPlot.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using Healpix\nusing Plots\npyplot()  # hide\n\nnside = 8\nm = HealpixMap{Float64, RingOrder}(nside)\nm.pixels[:] = 1:length(m.pixels)\nplot(m)\nsavefig(joinpath(\"images\", \"mollweide.png\")) # hide","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"A call to plot can provide two additional arguments:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"A carthographic projection (see below).\nA dictionary containing parameters to be used by the carthographic projection.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The following example displays the same map in orthographic coordinates:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"plot(m, orthographic)\nsavefig(joinpath(\"images\", \"orthographic.png\")) # hide","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"visualization/#Cartographic-projections","page":"Visualization","title":"Cartographic projections","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Plotting is based on project, which takes a map as input and produces a 2-D bitmap containing a representation of the map suitable to be shown using Plots.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Although the easiest way to plot a map is to use plot, project might be suitable in those cases where you are just interested in a 2D bitmap. It requires a inverse projection function (mapping the 2D plane to a point on the sphere) and the size of the bitmap, and it returns three values:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"A 2-D bitmap containing the color level of each pixel. Unseen pixels (e.g., those falling outside the ellipse in a Mollweide projection) are marked as NaN, as well as unseen pixels;\nA 2-D bitmap of Bool values, telling which pixels in the map are masked, i.e., they are marked as UNSEEN, NaN or missing in the Healpix map;\nA Bool flag telling if there is any masked value in the mask (2nd return value, see above). This parameter is returned to optimize calls to plot, but it is obviously redundant.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Consider this example:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"using Healpix\n\nm = HealpixMap{Float64, RingOrder}(1)\n# Plot the map on a 20×20 bitmap using an\n# equirectangular projection\nimage, mask, maskflag = project(equiprojinv, m, 20, 20)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"A number of parameters can be passed to project, in order to taylor the representation. They must not be passed as keyword arguments, because this would clash with the way plot recipes work; instead, you must use a dictionary:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"# Return a 2-D bitmap of 16-bit floating-point values\nimage, _, _ = project(equiprojinv, m, 20, 20,\n                      Dict(:desttype => Float16))","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The following dictionary keys are available:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":":desttype: type used for the pixels in the 2-D bitmap returned by project. Default is Float32;\n:unseen: the value marking pixels as unseen, i.e., masked. The default is -1.6375e+30, to preserve compatibility with other Healpix libraries.\n:center: currently this is used only with orthographic projections. It specifies the coordinates of the center of the image (colatitude and longitude, both in radians).","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"project","category":"page"},{"location":"visualization/#Healpix.project","page":"Visualization","title":"Healpix.project","text":"project(invprojfn, m::HealpixMap{T, O, AA}, bmpwidth, bmpheight; kwargs...)\n\nReturn a 2D bitmap (array) containing a cartographic projection of the map and a 2D bitmap containing a boolean mask. The size of the bitmap is bmpwidth×bmpheight pixels. The function projfn must be a function which accepts as input two parameters x and y (numbers between -1 and 1).\n\nThe following keywords can be used in the call:\n\ncenter: 2-tuple specifying the location (colatitude, longitude) of the sky point that is to be placed in the middle of the image (in radians)\nunseen: by default, Healpix maps use the value -1.6375e+30 to mark unseen pixels. You can specify a different value using this keyword. This should not be used in common applications.\n\nReturn a Array{Union{Missing, Float32}} containing the intensity of each pixel. Pixels falling outside the projection are marked as NaN, and unseen pixels are marked as missing.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Projection-functions","page":"Visualization","title":"Projection functions","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Functions mollweide, equirectangular, and orthographic can be passed as parameters to plot.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"mollweide\nequirectangular\northographic\northographic2\ngnomonic","category":"page"},{"location":"visualization/#Healpix.mollweide","page":"Visualization","title":"Healpix.mollweide","text":"mollweide(m::HealpixMap{T, O, AA}, projparams = Dict()) where {T <: Number, O, AA}\n\nHigh-level wrapper around project for Mollweide projections.\n\nThe following parameters can be set in the projparams dictionary:\n\nwidth: width of the image, in pixels (default: 720 pixels)\nheight: height of the image, in pixels; if not specified, it will be assumed to be equal to width\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.equirectangular","page":"Visualization","title":"Healpix.equirectangular","text":"equirectangular(m::HealpixMap{T,O,AA}; kwargs...) where {T <: Number, O, AA}\n\nHigh-level wrapper around project for equirectangular projections.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.orthographic","page":"Visualization","title":"Healpix.orthographic","text":"orthographic(m::HealpixMap{T,O}, projparams = Dict()) where {T <: Number,O <: Order}\n\nHigh-level wrapper around project for orthographic projections.\n\nThe following parameters can be set in the projparams dictionary:\n\nwidth: width of the image, in pixels (default: 720 pixels)\nheight: height of the image, in pixels; if not specified, it will be assumed to be equal to width\ncenter: position of the pixel in the middle of the left globe (latitude and longitude).\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.orthographic2","page":"Visualization","title":"Healpix.orthographic2","text":"orthographic2(m::HealpixMap{T, O, AA}, projparams = Dict()) where {T <: Number, O, AA}\n\nHigh-level wrapper around project for stereo orthographic projections.\n\nThe following parameters can be set in the projparams dictionary:\n\nwidth: width of the image, in pixels (default: 720 pixels)\nheight: height of the image, in pixels; if not specified, it will be assumed to be equal to width\ncenter: position of the pixel in the middle of the left globe (latitude and longitude). Default is (0, 0).\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.gnomonic","page":"Visualization","title":"Healpix.gnomonic","text":"gnomonic(m::HealpixMap{T, O, AA}, projparams = Dict()) where {T <: Number, O, AA}\n\nHigh-level wrapper around project for gnomonic projections.\n\nThe following parameters can be set in the projparams dictionary:\n\nwidth: width of the image, in pixels (default: 720 pixels)\nheight: height of the image, in pixels; if not specified, it will be assumed to be equal to width\ncenter: position and orientation of the pixel in the middle. It is a 3-element tuple containing:\nThe latitude of the pixel, in radians\nThe longitude of the pixel, in radians\nThe rotation to be applied to the image, in radians\nfov_rad: size of the image along the x and y axes, in radians (default: 15°)\n\nExample\n\nplot(m, gnomonic, Dict(:fov_rad = deg2rad(1.5), :center = (0, 0, deg2rad(45))))\n\n\n\n\n\n","category":"function"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"They are based on inverse projection functions, i.e., functions that take a point in the plane -1 1 times -1 1 and return a tuple (Bool, Number, Number), where the first Boolean is true if the point falls within the projection, and the other two numbers are the latitude and longitude in radians.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"mollweideprojinv\nequiprojinv\northoinv\northo2inv\ngnominv","category":"page"},{"location":"visualization/#Healpix.mollweideprojinv","page":"Visualization","title":"Healpix.mollweideprojinv","text":"mollweideprojinv(x, y)\n\nInverse Mollweide projection. Given a point (x, y) on the plane, with x ∈ [-1, 1], y ∈ [-1, 1], return a 3-tuple of type (Bool, Number, Number). The boolean specifies if (x, y) falls within the map (true) or not (false), the second and third arguments are the latitude and longitude in radians.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.equiprojinv","page":"Visualization","title":"Healpix.equiprojinv","text":"equiprojinv(x, y)\n\nInverse equirectangular projection. Given a point (x, y) on the plane [-1, 1] × [-1, 1], return a tuple (Bool, Number, Number) where the first Boolean is a flag telling if the point falls within the projection (true) or not (false), and the two numbers are the latitude and longitude in radians.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.orthoinv","page":"Visualization","title":"Healpix.orthoinv","text":"orthoinv(x, y, ϕ1, λ0)\n\nInverse orthographic projection centered on (ϕ1, λ0). Given a point (x, y) on the plane, with x ∈ [-1, 1], y ∈ [-1, 1], return a 3-tuple of type (Bool, Number, Number). The boolean specifies if (x, y) falls within the map (true) or not (false), the second and third arguments are the latitude and longitude in radians.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.ortho2inv","page":"Visualization","title":"Healpix.ortho2inv","text":"function ortho2inv(x, y, ϕ1, λ0)\n\nInverse stereo orthographic projection centered on (ϕ1, λ0). Given a point (x, y) on the plane, with x ∈ [-1, 1], y ∈ [-1, 1], return a 3-tuple of type (Bool, Number, Number). The boolean specifies if (x, y) falls within the map (true) or not (false), the second and third arguments are the latitude and longitude in radians.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.gnominv","page":"Visualization","title":"Healpix.gnominv","text":"function gnominv(x, y, ϕ1, λ0, fov_rad)\n\nGnomonic projection centered on (ϕ1, λ0), with a field of view equal to fov_rad (in radians).  Given a point (x, y) on the plane, with x ∈ [-1, 1], y ∈ [-1, 1], return a 3-tuple of type (Bool, Number, Number). The boolean specifies if (x, y) falls within the map (true) or not (false), the second and third arguments are the latitude and longitude in radians.\n\n\n\n\n\n","category":"function"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"The direct project functions are available too.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"equiproj\nmollweideproj","category":"page"},{"location":"visualization/#Healpix.equiproj","page":"Visualization","title":"Healpix.equiproj","text":"equiproj(lat, lon)\n\nEquirectangular projection. Given the latitude lat (in radians) and the longitude (in radians), return a tuple (Bool, Number, Number) where the first Boolean is a flag telling if the point falls within the projection (true) or not (false), and the two numbers are the x and y coordinates of the point on the projection plane (both are in the range [−1, 1]).\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Healpix.mollweideproj","page":"Visualization","title":"Healpix.mollweideproj","text":"mollweideproj(lat, lon)\n\nMollweide projection. Given the latitude lat (in radians) and the longitude (in radians), return a tuple (Bool, Number, Number) where the first Boolean is a flag telling if the point falls within the projection (true) or not (false), and the two numbers are the x and y coordinates of the point on the projection plane (both are in the range [−1, 1]).\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using Healpix\nend","category":"page"},{"location":"#Healpix.jl:-an-implementation-of-the-Healpix-tessellation-scheme-in-Julia","page":"Introduction","title":"Healpix.jl: an implementation of the Healpix tessellation scheme in Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the documentation of the Healpix.jl package, an implementation of the Healpix spherical tessellation scheme written entirely in Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package has the main purpose of providing a Julia-only solution, so that it can easily be used on platforms not supported by the Healpix C++ library (e.g., Windows). This library implements algorithms for converting directions into pixel indices and vice versa. It supports both RING and NESTED schemes, and it employs Julia's powerful type system to avoid mistaking one scheme in place of the other.","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Dates # hide\nprintln(\"Documentation built on $(now()) using Julia $(VERSION).\") # hide","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
